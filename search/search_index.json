{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to bpfd bpfd is a system daemon for managing BPF programs. It is currently a work in progress! Why bpfd? bpfd seeks to solve the following problems: To allow multiple XDP programs to share the same interface To give administrators control over who can load programs and to allow them to define rules for ordering of networking BPF programs To allow programs to be loaded automatically at system launch time To simplify the packaging and loading of BPF-based infrastructure software (i.e Kubernetes CNI plugins) How does it work? bpfd is built using Aya an BPF library written in Rust. It offers two ways of interaction: bpfctl : a command line tool using GRPC It is expected that humans will use bpfctl whereas other applications on the system wishing to load programs using bpfd will use the GRPC. This allows for API bindings to be generated in any language supported by protocol buffers. We are initially targeting Go and Rust. In order to allow the attachment of multiple XDP programs to the same interface, we have implemented the libxdp multiprog protocol . Offering this in bpfd allows for XDP applications whose loader was not using libxdp to benefit from this. We are also hoping to find a way for applications linked with libxdp to use bpfd instead if it's in use in the system.","title":"Welcome to bpfd"},{"location":"#welcome-to-bpfd","text":"bpfd is a system daemon for managing BPF programs. It is currently a work in progress!","title":"Welcome to bpfd"},{"location":"#why-bpfd","text":"bpfd seeks to solve the following problems: To allow multiple XDP programs to share the same interface To give administrators control over who can load programs and to allow them to define rules for ordering of networking BPF programs To allow programs to be loaded automatically at system launch time To simplify the packaging and loading of BPF-based infrastructure software (i.e Kubernetes CNI plugins)","title":"Why bpfd?"},{"location":"#how-does-it-work","text":"bpfd is built using Aya an BPF library written in Rust. It offers two ways of interaction: bpfctl : a command line tool using GRPC It is expected that humans will use bpfctl whereas other applications on the system wishing to load programs using bpfd will use the GRPC. This allows for API bindings to be generated in any language supported by protocol buffers. We are initially targeting Go and Rust. In order to allow the attachment of multiple XDP programs to the same interface, we have implemented the libxdp multiprog protocol . Offering this in bpfd allows for XDP applications whose loader was not using libxdp to benefit from this. We are also hoping to find a way for applications linked with libxdp to use bpfd instead if it's in use in the system.","title":"How does it work?"},{"location":"building-bpfd/","text":"Setup and Building bpfd Development Environment Setup Rust Stable & Rust Nightly curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh export PATH=\"$HOME/.cargo/bin:$PATH\" rustup toolchain install nightly -c rustfmt,clippy,rust-src LLVM 11 or later (Linux package managers should provide a recent enough release) dnf based OS: sudo dnf install llvm-devel clang-devel elfutils-libelf-devel apt based OS: sudo apt install clang lldb lld libelf-dev gcc-multilib bpf-linker cargo install bpf-linker protoc dnf based OS: sudo dnf install protobuf-compiler apt based OS: sudo apt install protobuf-compiler go protobuf compiler extensions See Quick Start Guide for gRPC in Go for installation instructions A checkout of libbpf git clone https://github.com/libbpf/libbpf --branch v0.8.0 Perl dnf based OS: sudo dnf install perl apt based OS: sudo apt install perl Building bpfd To just test with the latest bpfd, containerized image are stored in quay.io/bpfd (see BPFD Container Images ). To build with local changes, use the following commands. If you are building bpfd for the first time OR the BPF code has changed: cargo xtask build-ebpf --libbpf-dir /path/to/libbpf If protobuf files have changed: cargo xtask build-proto To build bpfd and bpfctl: cargo build","title":"Setup and Building bpfd"},{"location":"building-bpfd/#setup-and-building-bpfd","text":"","title":"Setup and Building bpfd"},{"location":"building-bpfd/#development-environment-setup","text":"Rust Stable & Rust Nightly curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh export PATH=\"$HOME/.cargo/bin:$PATH\" rustup toolchain install nightly -c rustfmt,clippy,rust-src LLVM 11 or later (Linux package managers should provide a recent enough release) dnf based OS: sudo dnf install llvm-devel clang-devel elfutils-libelf-devel apt based OS: sudo apt install clang lldb lld libelf-dev gcc-multilib bpf-linker cargo install bpf-linker protoc dnf based OS: sudo dnf install protobuf-compiler apt based OS: sudo apt install protobuf-compiler go protobuf compiler extensions See Quick Start Guide for gRPC in Go for installation instructions A checkout of libbpf git clone https://github.com/libbpf/libbpf --branch v0.8.0 Perl dnf based OS: sudo dnf install perl apt based OS: sudo apt install perl","title":"Development Environment Setup"},{"location":"building-bpfd/#building-bpfd","text":"To just test with the latest bpfd, containerized image are stored in quay.io/bpfd (see BPFD Container Images ). To build with local changes, use the following commands. If you are building bpfd for the first time OR the BPF code has changed: cargo xtask build-ebpf --libbpf-dir /path/to/libbpf If protobuf files have changed: cargo xtask build-proto To build bpfd and bpfctl: cargo build","title":"Building bpfd"},{"location":"configuration/","text":"Configuration bpfd bpfd looks for a configuration file to be present at /etc/bpfd/bpfd.toml . If no file is found, defaults are assumed. There is an example at scripts/bpfd.toml , similar to: [ tls ] # REQUIRED ca_cert = \"/etc/bpfd/certs/ca/ca.pem\" cert = \"/etc/bpfd/certs/bpfd/bpfd.pem\" key = \"/etc/bpfd/certs/bpfd/bpfd.key\" client_cert = \"/etc/bpfd/certs/bpfd-client/bpfd-client.pem\" client_key = \"/etc/bpfd/certs/bpfd-client/bpfd-client.key\" [interfaces] [interface.eth0] xdp_mode = \"hw\" # Valid xdp modes are \"hw\", \"skb\" and \"drv\". Default: \"skb\". bpfctl and bpfd-agent (which is only used in Kubernetes type deployments) will also read the bpfd configuration file ( /etc/bpfd/bpfd.toml ) to retrieve the bpfd-client certificate file locations. Loading Programs at system launch time bpfd allows the user to specify certain bpf programs to always be loaded every time the daemon is started. To do so simply create .toml files in the /etc/bpfd/programs.d directory with the following syntax: NOTE: Users can specify multiple programs in a single .toml file OR multiple .toml files [[programs]] name = \"program0\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 50 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] } [[programs]] name = \"program1\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 55 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] }","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#bpfd","text":"bpfd looks for a configuration file to be present at /etc/bpfd/bpfd.toml . If no file is found, defaults are assumed. There is an example at scripts/bpfd.toml , similar to: [ tls ] # REQUIRED ca_cert = \"/etc/bpfd/certs/ca/ca.pem\" cert = \"/etc/bpfd/certs/bpfd/bpfd.pem\" key = \"/etc/bpfd/certs/bpfd/bpfd.key\" client_cert = \"/etc/bpfd/certs/bpfd-client/bpfd-client.pem\" client_key = \"/etc/bpfd/certs/bpfd-client/bpfd-client.key\" [interfaces] [interface.eth0] xdp_mode = \"hw\" # Valid xdp modes are \"hw\", \"skb\" and \"drv\". Default: \"skb\". bpfctl and bpfd-agent (which is only used in Kubernetes type deployments) will also read the bpfd configuration file ( /etc/bpfd/bpfd.toml ) to retrieve the bpfd-client certificate file locations.","title":"bpfd"},{"location":"configuration/#loading-programs-at-system-launch-time","text":"bpfd allows the user to specify certain bpf programs to always be loaded every time the daemon is started. To do so simply create .toml files in the /etc/bpfd/programs.d directory with the following syntax: NOTE: Users can specify multiple programs in a single .toml file OR multiple .toml files [[programs]] name = \"program0\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 50 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] } [[programs]] name = \"program1\" path = \"/usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o\" section_name = \"xdp\" program_type = \"xdp\" network_attach = { interface = \"eth0\" , priority = 55 , proceed_on = [ \"pass\" , \"dispatcher_return\" ] }","title":"Loading Programs at system launch time"},{"location":"example-bpf/","text":"Example BPF Programs Example applications that use the bpfd-go bindings can be found in examples/go-xdp-counter/ and examples/go-tc-counter/ . These examples and the associated documentation is intended to provide the basics on how to deploy and manage a BPF program using bpfd. There are two ways to deploy these example applications, simply run locally on one machine, or deploy to multiple nodes in a Kubernetes cluster. The go-xdp-counter and go-tc-counter examples each contain a BPF Program written in C ( xdp_counter.c and tc_counter.c ) that is compiled into BPF bytecode. The BPF program counts packets that are received on an interface and stores the packet and byte counts in a map that is accessible by the userspace portion. The go-xdp-counter and go-tc-counter examples each also have a userspace portion written in GO. When run locally, the userspace program makes gRPC calls to bpfd requesting bpfd to load the BPF program at the requested hook Point (XDP hook point or the TC hook point). When run in a Kubernetes deployment, the bpfd-agent makes gRPC calls to bpfd requesting bpfd to load the BPF program based on a BpfProgramConfig Custom Resource Definition (CRD), which is described in more detail below. Independent of the deployment, the userspace program then polls the BPF map every 3 seconds and logs the current counts. The userspace code is leveraging the cilium/ebpf library to manage the maps shared with the BPF program. The XDP and TC programs are very similar in functionality, and only vary where in the Linux networking stack they are inserted. Read more about XDP and TC programs here . Deploying Locally This section describes running bpfd and the example bpf programs on a local host. When running bpfd, it can be run as a process or run as a systemd service. Examples run the same, independent of how bpfd is deployed, other than requiring sudo or not. Building To build directly on a system, make sure all the prerequisites are met, then build. Prerequisites Assuming bpfd is already installed and running on the system All requirements defined by the cilium/ebpf package libbpf development package to get the required bpf c headers Fedora: sudo dnf install libbpf-devel Ubuntu: sudo apt-get install libbpf-dev Cilium's bpf2go binary go install github.com/cilium/ebpf/cmd/bpf2go@master Building Locally To build the C based BPF counter bytecode, run: cd src/bpfd/examples/go-xdp-counter/ go generate To build the Userspace GO Client run: cd src/bpfd/examples/go-xdp-counter/ go build Repeat for TC if desired: cd src/bpfd/examples/go-tc-counter/ go generate go build Running On Host The most basic way to deploy this example is running directly on a host system. First, start or ensure bpfd is up and running. Tutorial will guide you through deploying bpfd . In all the examples of running go-xdp-counter or go-tc-counter on a host system, a bpfd-client certificate is used that is generated by bpfd to encrypt the application's connection to bpfd . The diagram below shows go-xdp-counter example, but the go-tc-counter example operates exactly the same way. Following the diagram (Purple numbers): When go-xdp-counter userspace is started, it will send a gRPC request over mTLS to bpfd requesting bpfd to load the go-xdp-counter BPF bytecode located on disk at bpfd/examples/go-xdp-counter/bpf_bpfel.o at a priority of 50 and on interface ens3 . These values are configurable as we will see later, but for now we will use the defaults (except interface, which is required to be entered). bpfd will load it's dispatcher BPF program, which links to the go-xdp-counter BPF program and return a UUID describing the running program. bpfctl list can be used to show that the BPF program was loaded. bpfctl also sends gRPC requests over mTLS to perform actions and request data from bpfd . Once the go-xdp-counter BPF bytecode is loaded, the BPF program will write packet counts and byte counts to a shared map. go-xdp-counter userspace program periodically reads counters from the shared map and logs the value. Running Privileged The most basic example, just use sudo to start the go-xdp-counter program. Determine the host interface to attach the BPF program to and then start the go program with: cd src/bpfd/examples/go-xdp-counter/ sudo ./go-xdp-counter -iface <INTERNET INTERFACE NAME> or ( NOTE: TC programs also require a direction, ingress or egress) cd src/bpfd/examples/go-tc-counter/ sudo ./go-tc-counter -direction ingress -iface <INTERNET INTERFACE NAME> The output should show the count and total bytes of packets as they pass through the interface as shown below: sudo ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 15:59:34 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : Use bpfctl to show the go-xdp-counter BPF bytecode was loaded. bpfctl list UUID Type Name Path Metadata b6b2107c-f1a3-48ac-a145-1073c0979ba4 xdp stats /home/$USER/src/bpfd/examples/go-xdp-counter/bpf_bpfel.o { \"priority\": 50, \"iface\": \"ens3\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } Finally, press <CTRL>+c when finished with go-xdp-counter . : 2022/12/02 16:00:56 64 packets received 2022/12/02 16:00:56 9280 bytes received 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4 Running Unprivileged To run the go-xdp-counter and go-tc-counter examples unprivileged (without sudo ), the following three steps must be performed. Step 1: Create bpfd User Group The Tutorial guide describes the different modes bpfd can be run in. Specifically, the Systemd Service section explains how to start bpfd and create the bpfd Users and bpfd User Group. bpfd must be started as a Systemd Service and go-xdp-counter must be run from a User that is a member of the bpfd User Group. sudo usermod -a -G bpfd $USER exit <LOGIN> Step 2: Grant CAP_BPF Linux Capability go-xdp-counter and go-tc-counter use a map to share data between the userspace side of the program and the BPF portion. Accessing this map requires access to the CAP_BPF capability. Run the following command to grant go-xdp-counter access to the CAP_BPF capability: cd src/bpfd/examples/go-xdp-counter/ sudo /sbin/setcap cap_dac_override,cap_bpf=ep ./go-xdp-counter and cd src/bpfd/examples/go-tc-counter/ sudo /sbin/setcap cap_dac_override,cap_bpf=ep ./go-tc-counter Reminder: The capability must be re-granted each time the examples are rebuilt. Step 3: Start go-xdp-counter without sudo Start go-xdp-counter without sudo : ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 15:59:34 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4 Passing BPF Bytecode In A Container Image bpfd can load BPF bytecode from a container image built following the spec described in EBPF Bytecode Image Specifications . Pre-built go-xdp-counter and go-tc-counter BPF container images can be loaded from quay.io/bpfd-bytecode/go-xdp-counter:latest or quay.io/bpfd-bytecode/go-tc-counter:latest . To use the container image, pass the URL to the userspace program: ./go-xdp-counter -iface ens3 -location image://quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:32 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 16:28:32 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 16:28:32 Using Input: Interface=ens3 Priority=50 Source=quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:34 Program registered with 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e id 2022/12/02 16:28:37 4 packets received 2022/12/02 16:28:37 580 bytes received 2022/12/02 16:28:40 4 packets received 2022/12/02 16:28:40 580 bytes received ^C2022/12/02 16:28:42 Exiting... 2022/12/02 16:28:42 Unloading Program: 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e Building BPF Bytecode Container Image EBPF Bytecode Image Specifications provides detailed instructions on building and shipping bytecode in a container image. To build go-xdp-counter and go-tc-counter BPF bytecode container image, first make sure the bytecode has been built (i.e. bpf_bpfel.o has been built - see Building , then run the build commands below: cd src/bpfd/examples/go-xdp-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-xdp-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=xdp \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-xdp-counter-bytecode:latest and cd src/bpfd/examples/go-tc-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-tc-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=tc \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tc-counter-bytecode:latest bpfd currently only supports pulling a remote container image, so push the image to a remote repository. For example: docker login quay.io docker push quay.io/$USER/go-xdp-counter-bytecode:latest docker push quay.io/$USER/go-tc-counter-bytecode:latest Then run with the privately built bytecode container image: ./go-tc-counter -iface ens3 -direction ingress -location image://quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:44 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 16:38:44 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 16:38:44 Using Input: Interface=ens3 Priority=50 Source=quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:45 Program registered with 0d313a4a-a17c-4c70-81ba-3ecc494b900e id 2022/12/02 16:38:48 4 packets received 2022/12/02 16:38:48 580 bytes received 2022/12/02 16:38:51 4 packets received 2022/12/02 16:38:51 580 bytes received ^C2022/12/02 16:38:51 Exiting... 2022/12/02 16:38:51 Unloading Program: 0d313a4a-a17c-4c70-81ba-3ecc494b900e Preloading BPF Bytecode Another way to load the BPF bytecode is to pre-load the BPF bytecode and pass the associated bpfd UUID to the userspace program. This is similar to how BPF programs will be loaded in Kubernetes, except kubectl commands will be used to create bpfProgramConfig kubernetes object objects instead of using bpfctl , but that is covered in the next section. The userspace programs will skip the loading portion and use the UUID to find the shared map and continue from there. Referring back to the diagram above, the load and unload are being done by bpfctl and not go-xdp-counter userspace program. First, use bpfctl to load the go-xdp-counter BPF bytecode: bpfctl load --location image://quay.io/bpfd-bytecode/go-xdp-counter:latest xdp --iface ens3 --priority 50 d541af30-69be-44cf-9397-407ee512547a Then run the go-xdp-counter userspace program, passing in the UUID: ./go-xdp-counter -iface ens3 -uuid d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:38 Using Input: Interface=ens3 Source=d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:41 180 packets received 2022/12/02 17:01:41 26100 bytes received 2022/12/02 17:01:44 184 packets received 2022/12/02 17:01:44 26680 bytes received ^C2022/12/02 17:01:46 Exiting... Then use bpfctl to unload the BPF bytecode: bpfctl unload d541af30-69be-44cf-9397-407ee512547a Deploying On Kubernetes This section will describe loading bytecode on a Kubernetes cluster and launching the userspace program. The approach is slightly different when running on a Kubernetes cluster. The BPF bytecode should be loaded by an administrator, not the userspace program itself. Loading BPF Bytecode On Kubernetes This assumes there is already a Kubernetes cluster running and bpfd is running in the cluster (see How to Manually Deploy bpfd on Kubernetes ). Instead of using the userspace program or bpfctl to load the BPF bytecode as done above, the bytecode will be loaded by creating a BpfProgramConfig kubernetes object. Edit the go-xdp-counter-bytecode.yaml file to customize, primarily setting the interface. Also note that the BpfProgramConfig is running the bytecode on all nodes ( nodeselector: {} ). This can be change to run on specific nodes, but the DaemonSet yaml for the userspace program, which is described below, should have an equivalent change (see go-xdp-counter.yaml ). vi examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgramConfig metadata: labels: app.kubernetes.io/name: bpfprogramconfig name: go-xdp-counter-example spec: # # Must correspond to image section name name: stats type: XDP # Select all nodes nodeselector: {} attachpoint: networkmultiattach: interface: eth0 priority: 55 bytecode: image://quay.io/bpfd-bytecode/go-xdp-counter-latest Repeat for go-tc-counter-bytecode.yaml and then apply the updated yamls: kubectl apply -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml bpfprogramconfig.bpfd.io/go-xdp-counter-example created kubectl apply -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml bpfprogramconfig.bpfd.io/go-tc-counter-example created Following the diagram (Blue numbers): The user creates a BpfProgramConfig object with the parameters associated with the BPF bytecode, like interface, priority and BFP bytecode image. The name of the BpfProgramConfig object in this example is go-xdp-counter-example . bpfd-agent , running on each node, is watching for all changes to BpfProgramConfig objects. When it sees a BpfProgramConfig object modified, it makes sure a BpfProgram object for that node exists. The name of the BpfProgram object is the BpfProgramConfig object name with the node name appended. bpfd-agent then determines if it should be running on the given node, loads or unloads as needed by making gRPC calls the bpfd . bpfd behaves the same as described in the running locally example. bpfd-agent finally updates the status of the BpfProgram object. bpfd-operator watches all BpfProgram objects, and updates the status of the BpfProgramConfig object indicating if the BPF program has been applied to all the desired nodes or not. To retrieve information on the BpfProgramConfig objects: kubectl get bpfprogramconfigs NAME AGE go-tc-counter-example 3d5h go-xdp-counter-example 3d5h kubectl get bpfprogramconfigs go-xdp-counter-example -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgramConfig metadata: creationTimestamp: \"2023-01-06T15:04:22Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: bpfprogramconfig name: go-xdp-counter-example resourceVersion: \"268771\" uid: 81a9d2ea-52fc-4c5a-8a57-d3189119fad2 spec: attachpoint: networkmultiattach: direction: NONE interface: eth0 priority: 55 bytecode: image://quay.io/bpfd-bytecode/go-xdp-counter:latest name: stats nodeselector: {} type: XDP status: conditions: - lastTransitionTime: \"2023-01-06T15:04:22Z\" message: Waiting for BpfProgramConfig Object to be reconciled to all nodes reason: ProgramsNotYetLoaded status: \"True\" type: NotYetLoaded - lastTransitionTime: \"2023-01-06T15:04:22Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess To retrieve information on the BpfProgram objects: kubectl get bpfprograms NAME AGE go-tc-counter-example-bpfd-deployment-control-plane 3d5h go-tc-counter-example-bpfd-deployment-worker 3d5h go-tc-counter-example-bpfd-deployment-worker2 3d5h go-xdp-counter-example-bpfd-deployment-control-plane 3d5h go-xdp-counter-example-bpfd-deployment-worker 3d5h go-xdp-counter-example-bpfd-deployment-worker2 3d5h kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgram metadata: creationTimestamp: \"2023-01-06T15:04:22Z\" finalizers: - bpfd.io.agent/finalizer generation: 2 labels: owningConfig: go-xdp-counter-example name: go-xdp-counter-example-bpfd-deployment-worker ownerReferences: - apiVersion: bpfd.io/v1alpha1 blockOwnerDeletion: true controller: true kind: BpfProgramConfig name: go-xdp-counter-example uid: 81a9d2ea-52fc-4c5a-8a57-d3189119fad2 resourceVersion: \"268828\" uid: 7957b711-d752-4893-8a8d-7d48c3afaa53 spec: programs: 30f8264a-ba07-4adc-9824-85a2c755e85e: attachpoint: networkmultiattach: direction: NONE interface: eth0 priority: 55 proceedon: [] maps: xdp_stats_map: /run/bpfd/fs/maps/30f8264a-ba07-4adc-9824-85a2c755e85e/xdp_stats_map status: conditions: - lastTransitionTime: \"2023-01-06T15:04:23Z\" message: Successfully loaded bpfProgram reason: bpfdLoaded status: \"True\" type: Loaded Loading Userspace Container On Kubernetes Building A Userspace Container Image To build the go-xdp-counter and go-tc-counter userspace examples in a container, from the bpfd code source directory, run the following build commands: cd src/bpfd/ docker build -f examples/go-xdp-counter/container-deployment/Containerfile.go-xdp-counter . -t quay.io/$USER/go-xdp-counter:latest docker build -f examples/go-tc-counter/container-deployment/Containerfile.go-tc-counter . -t quay.io/$USER/go-tc-counter:latest Then push images to a remote repository: docker login quay.io docker push quay.io/$USER/go-xdp-counter:latest docker push quay.io/$USER/go-tc-counter:latest Loading A Userspace Container Image The userspace program in a Kubernetes Deployment no longer interacts directly with bpfd . Instead, the userspace program running on each node reads the BpdProgram to determine the map location. For example, the output above shows the maps as: kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml : spec: programs: 30f8264a-ba07-4adc-9824-85a2c755e85e: : maps: xdp_stats_map: /run/bpfd/fs/maps/30f8264a-ba07-4adc-9824-85a2c755e85e/xdp_stats_map : To interact with the KubeApiServer, RBAC must be setup properly to access the BpdProgram object. The bpfd-operator defined the yaml for several ClusterRoles that can be used to access the different bpfd related CRD objects with different access rights. The example userspace containers will use the bpfprogram-viewer-role , which allows Read-Only access to the BpfProgram object. This ClusterRole is created automatically by the bpfd-operator . The remaining objects (NameSpace, ServiceAccount, ClusterRoleBinding and examples DaemonSet) also need to be created. cd src/bpfd/ kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml Following the diagram (Green numbers): The userspace program queries the KubeApiServer for a specific BpfProgram object. The userspace program pulls the file location of the shared map out of the BpfProgram object and uses the file to periodically read the counter values. To see if the userspace programs are working, view the logs: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE : go-tc-counter go-tc-counter-ds-k7vmp 1/1 Running 0 3d7h go-tc-counter go-tc-counter-ds-r77mq 1/1 Running 0 3d7h go-tc-counter go-tc-counter-ds-wds65 1/1 Running 0 3d7h go-xdp-counter go-xdp-counter-ds-5q4hz 1/1 Running 0 3d7h go-xdp-counter go-xdp-counter-ds-bbm9c 1/1 Running 0 3d7h go-xdp-counter go-xdp-counter-ds-dn247 1/1 Running 0 3d7h : kubectl logs -n go-xdp-counter go-xdp-counter-ds-5q4hz 2023/01/08 08:47:55 908748 packets received 2023/01/08 08:47:55 631463477 bytes received 2023/01/08 08:47:58 908757 packets received 2023/01/08 08:47:58 631466099 bytes received 2023/01/08 08:48:01 908778 packets received 2023/01/08 08:48:01 631472201 bytes received 2023/01/08 08:48:04 908791 packets received 2023/01/08 08:48:04 631480013 bytes received : To cleanup: kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml Notes Notes regarding this document: Source of images used in this document can be found in bpfd Upstream Images . Request access if required.","title":"Example BPF Programs"},{"location":"example-bpf/#example-bpf-programs","text":"Example applications that use the bpfd-go bindings can be found in examples/go-xdp-counter/ and examples/go-tc-counter/ . These examples and the associated documentation is intended to provide the basics on how to deploy and manage a BPF program using bpfd. There are two ways to deploy these example applications, simply run locally on one machine, or deploy to multiple nodes in a Kubernetes cluster. The go-xdp-counter and go-tc-counter examples each contain a BPF Program written in C ( xdp_counter.c and tc_counter.c ) that is compiled into BPF bytecode. The BPF program counts packets that are received on an interface and stores the packet and byte counts in a map that is accessible by the userspace portion. The go-xdp-counter and go-tc-counter examples each also have a userspace portion written in GO. When run locally, the userspace program makes gRPC calls to bpfd requesting bpfd to load the BPF program at the requested hook Point (XDP hook point or the TC hook point). When run in a Kubernetes deployment, the bpfd-agent makes gRPC calls to bpfd requesting bpfd to load the BPF program based on a BpfProgramConfig Custom Resource Definition (CRD), which is described in more detail below. Independent of the deployment, the userspace program then polls the BPF map every 3 seconds and logs the current counts. The userspace code is leveraging the cilium/ebpf library to manage the maps shared with the BPF program. The XDP and TC programs are very similar in functionality, and only vary where in the Linux networking stack they are inserted. Read more about XDP and TC programs here .","title":"Example BPF Programs"},{"location":"example-bpf/#deploying-locally","text":"This section describes running bpfd and the example bpf programs on a local host. When running bpfd, it can be run as a process or run as a systemd service. Examples run the same, independent of how bpfd is deployed, other than requiring sudo or not.","title":"Deploying Locally"},{"location":"example-bpf/#building","text":"To build directly on a system, make sure all the prerequisites are met, then build.","title":"Building"},{"location":"example-bpf/#prerequisites","text":"Assuming bpfd is already installed and running on the system All requirements defined by the cilium/ebpf package libbpf development package to get the required bpf c headers Fedora: sudo dnf install libbpf-devel Ubuntu: sudo apt-get install libbpf-dev Cilium's bpf2go binary go install github.com/cilium/ebpf/cmd/bpf2go@master","title":"Prerequisites"},{"location":"example-bpf/#building-locally","text":"To build the C based BPF counter bytecode, run: cd src/bpfd/examples/go-xdp-counter/ go generate To build the Userspace GO Client run: cd src/bpfd/examples/go-xdp-counter/ go build Repeat for TC if desired: cd src/bpfd/examples/go-tc-counter/ go generate go build","title":"Building Locally"},{"location":"example-bpf/#running-on-host","text":"The most basic way to deploy this example is running directly on a host system. First, start or ensure bpfd is up and running. Tutorial will guide you through deploying bpfd . In all the examples of running go-xdp-counter or go-tc-counter on a host system, a bpfd-client certificate is used that is generated by bpfd to encrypt the application's connection to bpfd . The diagram below shows go-xdp-counter example, but the go-tc-counter example operates exactly the same way. Following the diagram (Purple numbers): When go-xdp-counter userspace is started, it will send a gRPC request over mTLS to bpfd requesting bpfd to load the go-xdp-counter BPF bytecode located on disk at bpfd/examples/go-xdp-counter/bpf_bpfel.o at a priority of 50 and on interface ens3 . These values are configurable as we will see later, but for now we will use the defaults (except interface, which is required to be entered). bpfd will load it's dispatcher BPF program, which links to the go-xdp-counter BPF program and return a UUID describing the running program. bpfctl list can be used to show that the BPF program was loaded. bpfctl also sends gRPC requests over mTLS to perform actions and request data from bpfd . Once the go-xdp-counter BPF bytecode is loaded, the BPF program will write packet counts and byte counts to a shared map. go-xdp-counter userspace program periodically reads counters from the shared map and logs the value.","title":"Running On Host"},{"location":"example-bpf/#running-privileged","text":"The most basic example, just use sudo to start the go-xdp-counter program. Determine the host interface to attach the BPF program to and then start the go program with: cd src/bpfd/examples/go-xdp-counter/ sudo ./go-xdp-counter -iface <INTERNET INTERFACE NAME> or ( NOTE: TC programs also require a direction, ingress or egress) cd src/bpfd/examples/go-tc-counter/ sudo ./go-tc-counter -direction ingress -iface <INTERNET INTERFACE NAME> The output should show the count and total bytes of packets as they pass through the interface as shown below: sudo ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 15:59:34 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : Use bpfctl to show the go-xdp-counter BPF bytecode was loaded. bpfctl list UUID Type Name Path Metadata b6b2107c-f1a3-48ac-a145-1073c0979ba4 xdp stats /home/$USER/src/bpfd/examples/go-xdp-counter/bpf_bpfel.o { \"priority\": 50, \"iface\": \"ens3\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } Finally, press <CTRL>+c when finished with go-xdp-counter . : 2022/12/02 16:00:56 64 packets received 2022/12/02 16:00:56 9280 bytes received 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4","title":"Running Privileged"},{"location":"example-bpf/#running-unprivileged","text":"To run the go-xdp-counter and go-tc-counter examples unprivileged (without sudo ), the following three steps must be performed.","title":"Running Unprivileged"},{"location":"example-bpf/#step-1-create-bpfd-user-group","text":"The Tutorial guide describes the different modes bpfd can be run in. Specifically, the Systemd Service section explains how to start bpfd and create the bpfd Users and bpfd User Group. bpfd must be started as a Systemd Service and go-xdp-counter must be run from a User that is a member of the bpfd User Group. sudo usermod -a -G bpfd $USER exit <LOGIN>","title":"Step 1: Create bpfd User Group"},{"location":"example-bpf/#step-2-grant-cap_bpf-linux-capability","text":"go-xdp-counter and go-tc-counter use a map to share data between the userspace side of the program and the BPF portion. Accessing this map requires access to the CAP_BPF capability. Run the following command to grant go-xdp-counter access to the CAP_BPF capability: cd src/bpfd/examples/go-xdp-counter/ sudo /sbin/setcap cap_dac_override,cap_bpf=ep ./go-xdp-counter and cd src/bpfd/examples/go-tc-counter/ sudo /sbin/setcap cap_dac_override,cap_bpf=ep ./go-tc-counter Reminder: The capability must be re-granted each time the examples are rebuilt.","title":"Step 2: Grant CAP_BPF Linux Capability"},{"location":"example-bpf/#step-3-start-go-xdp-counter-without-sudo","text":"Start go-xdp-counter without sudo : ./go-xdp-counter -iface ens3 2022/12/02 15:59:34 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 15:59:34 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 15:59:34 Using Input: Interface=ens3 Priority=50 Source=bpf_bpfel.o 2022/12/02 15:59:35 Program registered with b6b2107c-f1a3-48ac-a145-1073c0979ba4 id 2022/12/02 15:59:38 0 packets received 2022/12/02 15:59:38 0 bytes received 2022/12/02 15:59:41 4 packets received 2022/12/02 15:59:41 580 bytes received : 2022/12/02 16:00:59 64 packets received 2022/12/02 16:00:59 9280 bytes received ^C2022/12/02 16:01:00 Exiting... 2022/12/02 16:01:00 Unloading Program: b6b2107c-f1a3-48ac-a145-1073c0979ba4","title":"Step 3: Start go-xdp-counter without sudo"},{"location":"example-bpf/#passing-bpf-bytecode-in-a-container-image","text":"bpfd can load BPF bytecode from a container image built following the spec described in EBPF Bytecode Image Specifications . Pre-built go-xdp-counter and go-tc-counter BPF container images can be loaded from quay.io/bpfd-bytecode/go-xdp-counter:latest or quay.io/bpfd-bytecode/go-tc-counter:latest . To use the container image, pass the URL to the userspace program: ./go-xdp-counter -iface ens3 -location image://quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:32 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 16:28:32 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 16:28:32 Using Input: Interface=ens3 Priority=50 Source=quay.io/bpfd-bytecode/go-xdp-counter:latest 2022/12/02 16:28:34 Program registered with 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e id 2022/12/02 16:28:37 4 packets received 2022/12/02 16:28:37 580 bytes received 2022/12/02 16:28:40 4 packets received 2022/12/02 16:28:40 580 bytes received ^C2022/12/02 16:28:42 Exiting... 2022/12/02 16:28:42 Unloading Program: 8d89a6b6-bce2-4d3f-9cee-9cb0c689a90e","title":"Passing BPF Bytecode In A Container Image"},{"location":"example-bpf/#building-bpf-bytecode-container-image","text":"EBPF Bytecode Image Specifications provides detailed instructions on building and shipping bytecode in a container image. To build go-xdp-counter and go-tc-counter BPF bytecode container image, first make sure the bytecode has been built (i.e. bpf_bpfel.o has been built - see Building , then run the build commands below: cd src/bpfd/examples/go-xdp-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-xdp-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=xdp \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-xdp-counter-bytecode:latest and cd src/bpfd/examples/go-tc-counter/ go generate docker build \\ --build-arg PROGRAM_NAME=go-tc-counter \\ --build-arg SECTION_NAME=stats \\ --build-arg PROGRAM_TYPE=tc \\ --build-arg BYTECODE_FILENAME=bpf_bpfel.o \\ --build-arg KERNEL_COMPILE_VER=$(uname -r) \\ -f ../../packaging/container-deployment/Containerfile.bytecode . -t quay.io/$USER/go-tc-counter-bytecode:latest bpfd currently only supports pulling a remote container image, so push the image to a remote repository. For example: docker login quay.io docker push quay.io/$USER/go-xdp-counter-bytecode:latest docker push quay.io/$USER/go-tc-counter-bytecode:latest Then run with the privately built bytecode container image: ./go-tc-counter -iface ens3 -direction ingress -location image://quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:44 Reading /etc/bpfd/gocounter.toml ... 2022/12/02 16:38:44 Read /etc/bpfd/gocounter.toml failed: err open /etc/bpfd/gocounter.toml: no such file or directory 2022/12/02 16:38:44 Using Input: Interface=ens3 Priority=50 Source=quay.io/$USER/go-tc-counter-bytecode:latest 2022/12/02 16:38:45 Program registered with 0d313a4a-a17c-4c70-81ba-3ecc494b900e id 2022/12/02 16:38:48 4 packets received 2022/12/02 16:38:48 580 bytes received 2022/12/02 16:38:51 4 packets received 2022/12/02 16:38:51 580 bytes received ^C2022/12/02 16:38:51 Exiting... 2022/12/02 16:38:51 Unloading Program: 0d313a4a-a17c-4c70-81ba-3ecc494b900e","title":"Building BPF Bytecode Container Image"},{"location":"example-bpf/#preloading-bpf-bytecode","text":"Another way to load the BPF bytecode is to pre-load the BPF bytecode and pass the associated bpfd UUID to the userspace program. This is similar to how BPF programs will be loaded in Kubernetes, except kubectl commands will be used to create bpfProgramConfig kubernetes object objects instead of using bpfctl , but that is covered in the next section. The userspace programs will skip the loading portion and use the UUID to find the shared map and continue from there. Referring back to the diagram above, the load and unload are being done by bpfctl and not go-xdp-counter userspace program. First, use bpfctl to load the go-xdp-counter BPF bytecode: bpfctl load --location image://quay.io/bpfd-bytecode/go-xdp-counter:latest xdp --iface ens3 --priority 50 d541af30-69be-44cf-9397-407ee512547a Then run the go-xdp-counter userspace program, passing in the UUID: ./go-xdp-counter -iface ens3 -uuid d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:38 Using Input: Interface=ens3 Source=d541af30-69be-44cf-9397-407ee512547a 2022/12/02 17:01:41 180 packets received 2022/12/02 17:01:41 26100 bytes received 2022/12/02 17:01:44 184 packets received 2022/12/02 17:01:44 26680 bytes received ^C2022/12/02 17:01:46 Exiting... Then use bpfctl to unload the BPF bytecode: bpfctl unload d541af30-69be-44cf-9397-407ee512547a","title":"Preloading BPF Bytecode"},{"location":"example-bpf/#deploying-on-kubernetes","text":"This section will describe loading bytecode on a Kubernetes cluster and launching the userspace program. The approach is slightly different when running on a Kubernetes cluster. The BPF bytecode should be loaded by an administrator, not the userspace program itself.","title":"Deploying On Kubernetes"},{"location":"example-bpf/#loading-bpf-bytecode-on-kubernetes","text":"This assumes there is already a Kubernetes cluster running and bpfd is running in the cluster (see How to Manually Deploy bpfd on Kubernetes ). Instead of using the userspace program or bpfctl to load the BPF bytecode as done above, the bytecode will be loaded by creating a BpfProgramConfig kubernetes object. Edit the go-xdp-counter-bytecode.yaml file to customize, primarily setting the interface. Also note that the BpfProgramConfig is running the bytecode on all nodes ( nodeselector: {} ). This can be change to run on specific nodes, but the DaemonSet yaml for the userspace program, which is described below, should have an equivalent change (see go-xdp-counter.yaml ). vi examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgramConfig metadata: labels: app.kubernetes.io/name: bpfprogramconfig name: go-xdp-counter-example spec: # # Must correspond to image section name name: stats type: XDP # Select all nodes nodeselector: {} attachpoint: networkmultiattach: interface: eth0 priority: 55 bytecode: image://quay.io/bpfd-bytecode/go-xdp-counter-latest Repeat for go-tc-counter-bytecode.yaml and then apply the updated yamls: kubectl apply -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml bpfprogramconfig.bpfd.io/go-xdp-counter-example created kubectl apply -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml bpfprogramconfig.bpfd.io/go-tc-counter-example created Following the diagram (Blue numbers): The user creates a BpfProgramConfig object with the parameters associated with the BPF bytecode, like interface, priority and BFP bytecode image. The name of the BpfProgramConfig object in this example is go-xdp-counter-example . bpfd-agent , running on each node, is watching for all changes to BpfProgramConfig objects. When it sees a BpfProgramConfig object modified, it makes sure a BpfProgram object for that node exists. The name of the BpfProgram object is the BpfProgramConfig object name with the node name appended. bpfd-agent then determines if it should be running on the given node, loads or unloads as needed by making gRPC calls the bpfd . bpfd behaves the same as described in the running locally example. bpfd-agent finally updates the status of the BpfProgram object. bpfd-operator watches all BpfProgram objects, and updates the status of the BpfProgramConfig object indicating if the BPF program has been applied to all the desired nodes or not. To retrieve information on the BpfProgramConfig objects: kubectl get bpfprogramconfigs NAME AGE go-tc-counter-example 3d5h go-xdp-counter-example 3d5h kubectl get bpfprogramconfigs go-xdp-counter-example -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgramConfig metadata: creationTimestamp: \"2023-01-06T15:04:22Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: bpfprogramconfig name: go-xdp-counter-example resourceVersion: \"268771\" uid: 81a9d2ea-52fc-4c5a-8a57-d3189119fad2 spec: attachpoint: networkmultiattach: direction: NONE interface: eth0 priority: 55 bytecode: image://quay.io/bpfd-bytecode/go-xdp-counter:latest name: stats nodeselector: {} type: XDP status: conditions: - lastTransitionTime: \"2023-01-06T15:04:22Z\" message: Waiting for BpfProgramConfig Object to be reconciled to all nodes reason: ProgramsNotYetLoaded status: \"True\" type: NotYetLoaded - lastTransitionTime: \"2023-01-06T15:04:22Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess To retrieve information on the BpfProgram objects: kubectl get bpfprograms NAME AGE go-tc-counter-example-bpfd-deployment-control-plane 3d5h go-tc-counter-example-bpfd-deployment-worker 3d5h go-tc-counter-example-bpfd-deployment-worker2 3d5h go-xdp-counter-example-bpfd-deployment-control-plane 3d5h go-xdp-counter-example-bpfd-deployment-worker 3d5h go-xdp-counter-example-bpfd-deployment-worker2 3d5h kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgram metadata: creationTimestamp: \"2023-01-06T15:04:22Z\" finalizers: - bpfd.io.agent/finalizer generation: 2 labels: owningConfig: go-xdp-counter-example name: go-xdp-counter-example-bpfd-deployment-worker ownerReferences: - apiVersion: bpfd.io/v1alpha1 blockOwnerDeletion: true controller: true kind: BpfProgramConfig name: go-xdp-counter-example uid: 81a9d2ea-52fc-4c5a-8a57-d3189119fad2 resourceVersion: \"268828\" uid: 7957b711-d752-4893-8a8d-7d48c3afaa53 spec: programs: 30f8264a-ba07-4adc-9824-85a2c755e85e: attachpoint: networkmultiattach: direction: NONE interface: eth0 priority: 55 proceedon: [] maps: xdp_stats_map: /run/bpfd/fs/maps/30f8264a-ba07-4adc-9824-85a2c755e85e/xdp_stats_map status: conditions: - lastTransitionTime: \"2023-01-06T15:04:23Z\" message: Successfully loaded bpfProgram reason: bpfdLoaded status: \"True\" type: Loaded","title":"Loading BPF Bytecode On Kubernetes"},{"location":"example-bpf/#loading-userspace-container-on-kubernetes","text":"","title":"Loading Userspace Container On Kubernetes"},{"location":"example-bpf/#building-a-userspace-container-image","text":"To build the go-xdp-counter and go-tc-counter userspace examples in a container, from the bpfd code source directory, run the following build commands: cd src/bpfd/ docker build -f examples/go-xdp-counter/container-deployment/Containerfile.go-xdp-counter . -t quay.io/$USER/go-xdp-counter:latest docker build -f examples/go-tc-counter/container-deployment/Containerfile.go-tc-counter . -t quay.io/$USER/go-tc-counter:latest Then push images to a remote repository: docker login quay.io docker push quay.io/$USER/go-xdp-counter:latest docker push quay.io/$USER/go-tc-counter:latest","title":"Building A Userspace Container Image"},{"location":"example-bpf/#loading-a-userspace-container-image","text":"The userspace program in a Kubernetes Deployment no longer interacts directly with bpfd . Instead, the userspace program running on each node reads the BpdProgram to determine the map location. For example, the output above shows the maps as: kubectl get bpfprograms go-xdp-counter-example-bpfd-deployment-worker -o yaml : spec: programs: 30f8264a-ba07-4adc-9824-85a2c755e85e: : maps: xdp_stats_map: /run/bpfd/fs/maps/30f8264a-ba07-4adc-9824-85a2c755e85e/xdp_stats_map : To interact with the KubeApiServer, RBAC must be setup properly to access the BpdProgram object. The bpfd-operator defined the yaml for several ClusterRoles that can be used to access the different bpfd related CRD objects with different access rights. The example userspace containers will use the bpfprogram-viewer-role , which allows Read-Only access to the BpfProgram object. This ClusterRole is created automatically by the bpfd-operator . The remaining objects (NameSpace, ServiceAccount, ClusterRoleBinding and examples DaemonSet) also need to be created. cd src/bpfd/ kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml Following the diagram (Green numbers): The userspace program queries the KubeApiServer for a specific BpfProgram object. The userspace program pulls the file location of the shared map out of the BpfProgram object and uses the file to periodically read the counter values. To see if the userspace programs are working, view the logs: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE : go-tc-counter go-tc-counter-ds-k7vmp 1/1 Running 0 3d7h go-tc-counter go-tc-counter-ds-r77mq 1/1 Running 0 3d7h go-tc-counter go-tc-counter-ds-wds65 1/1 Running 0 3d7h go-xdp-counter go-xdp-counter-ds-5q4hz 1/1 Running 0 3d7h go-xdp-counter go-xdp-counter-ds-bbm9c 1/1 Running 0 3d7h go-xdp-counter go-xdp-counter-ds-dn247 1/1 Running 0 3d7h : kubectl logs -n go-xdp-counter go-xdp-counter-ds-5q4hz 2023/01/08 08:47:55 908748 packets received 2023/01/08 08:47:55 631463477 bytes received 2023/01/08 08:47:58 908757 packets received 2023/01/08 08:47:58 631466099 bytes received 2023/01/08 08:48:01 908778 packets received 2023/01/08 08:48:01 631472201 bytes received 2023/01/08 08:48:04 908791 packets received 2023/01/08 08:48:04 631480013 bytes received : To cleanup: kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml kubectl delete -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml kubectl delete -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml","title":"Loading A Userspace Container Image"},{"location":"example-bpf/#notes","text":"Notes regarding this document: Source of images used in this document can be found in bpfd Upstream Images . Request access if required.","title":"Notes"},{"location":"image-build/","text":"BPFD Container Images Container images for the bpfd and bpfctl binaries are automatically built and pushed to quay.io/bpfd whenever code is merged into the main branch of the github.com/redhat-et/bpfd repository under the :main tag. Building the images locally bpfd docker build -f /packaging/container-deployment/Containerfile.bpfd . -t bpfd:local bpfctl docker build -f /packaging/container-deployment/Containerfile.bpfctl . -t bpfctl:local Running locally in container bpfd sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ -v /sys/fs/bpf:/sys/fs/bpf quay.io/bpfd/bpfd:main bpfctl sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ quay.io/bpfd/bpfctl:main <COMMANDS>","title":"BPFD Container Images"},{"location":"image-build/#bpfd-container-images","text":"Container images for the bpfd and bpfctl binaries are automatically built and pushed to quay.io/bpfd whenever code is merged into the main branch of the github.com/redhat-et/bpfd repository under the :main tag.","title":"BPFD Container Images"},{"location":"image-build/#building-the-images-locally","text":"","title":"Building the images locally"},{"location":"image-build/#bpfd","text":"docker build -f /packaging/container-deployment/Containerfile.bpfd . -t bpfd:local","title":"bpfd"},{"location":"image-build/#bpfctl","text":"docker build -f /packaging/container-deployment/Containerfile.bpfctl . -t bpfctl:local","title":"bpfctl"},{"location":"image-build/#running-locally-in-container","text":"","title":"Running locally in container"},{"location":"image-build/#bpfd_1","text":"sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ -v /sys/fs/bpf:/sys/fs/bpf quay.io/bpfd/bpfd:main","title":"bpfd"},{"location":"image-build/#bpfctl_1","text":"sudo docker run --init --privileged --net = host -v /etc/bpfd/certs/:/etc/bpfd/certs/ quay.io/bpfd/bpfctl:main <COMMANDS>","title":"bpfctl"},{"location":"k8s-deployment/","text":"How to Deploy bpfd on Kubernetes One of the key use cases for bpfd is to support the deployment of BPF programs in Kubernetes clusters. The simplest way to do this is to use the bpfd-operator. In this document, we provide an overview of using the bpfd-operator as well as the manual steps required to use bpfd with Kubernetes, in general, and OpenShift, in particular. bpfd-operator Overview The Bpfd-Operator can be used to deploy and manage bpfd within a Kubernetes cluster. The bpfd-operator repository houses two main processes, the bpfd-agent and the bpfd-operator along with CRD api definitions for BpfProgram and BpfProgramConfig Objects. In the below sections we'll dive a bit deeper into the API and functionality of both processes. Deployment Options Choose one of the install options described below, and then go to Verify the installation below to make sure it worked. Quick Start with kind and the bpfd-operator Using kind with the bpfd-operator is an easy way to spin up a local kind cluster and deploy bpfd. Pre-requsites Install git , make , and go Install Docker for your platform. We also recommend that you follow the Post-installation steps for Linux to allow your user to run Docker commands without root priviledges. Install kubctl and kind Installation Instructions clone the bpfd repository git clone https://github.com/redhat-et/bpfd.git cd bpfd/bpfd-operator The bpfd-operator was built utilizing some great tooling provided by the operator-sdk library . A great first step in understanding some of the functionality can be to cd into the bpfd/bpfd-operator directory and run make help . Deploy locally via KIND After reviewing the possible make targets it's quick and easy to get bpfd deployed locally on your system via a KIND cluster with: make run-on-kind NOTE: You will need a spare 20G in your root partition to run make run-on-kind , and it will take a while the first time you run it. By default local image builds will be used for the kind deployment, however, the container images used for bpfd , bpfd-agent , and bpfd-operator can also be configured as follows. BPFD_IMG = <your/image/url> BPFD_AGENT_IMG = <your/image/url> BPFD_OPERATOR_IMG = <your/image/url> make run-on-kind To push and test out any local changes simply run: make kind-reload-images To tear down the kind cluster, run: kind delete cluster -n bpfd-deployment The default name of the created cluster is bpfd-deployment . To retrieve all the created kind clusters, use kind get clusters Deploy To Openshift Cluster First install cert-manager (if not already deployed) to the cluster with: make deploy-cert-manager Then deploy the operator with one of the following two options: 1. Manually with Kustomize Then to install manually with Kustomize and raw manifests simply run: make deploy-openshift Which can then be cleaned up with: make undeploy-openshift 2. Via the OLM bundle The bpfd-operator can also be installed via it's OLM bundle . First setup the namespace and certificates for the operator with: oc apply -f ./hack/ocp-scc-hacks.yaml Then use operator-sdk to install the bundle like so: operator-sdk run bundle quay.io/bpfd/bpfd-operator-bundle:latest --namespace openshift-bpfd To clean everything up run: operator-sdk cleanup bpfd-operator followed by oc delete -f ./hack/ocp-scc-hacks.yaml Verify the installation NOTE: The commands in this section were run on a local kind deployment. If the bpfd-operator came up successfully you will see the bpfd-daemon and bpfd-operator pods running without errors: kubectl get pods -n bpfd NAME READY STATUS RESTARTS AGE bpfd-daemon-6d4qm 2 /2 Running 0 75m bpfd-daemon-929tf 2 /2 Running 0 75m bpfd-daemon-ftpwn 2 /2 Running 0 75m bpfd-operator-685db895b7-9qqrs 2 /2 Running 0 75m To test the deployment, load one or both of the example programs. NOTE: The example BpfProgramConfig CRDs assume that the programs will be run on eth0 , which is the default for the kind deployment. If you need to run the programs on a different interface, modify interface in the associated file: examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml , or examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml Load the example xdp kernel and user space programs: kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml Load the example tc kernel and user space programs: kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml Verify that they are loaded: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE : go-tc-counter go-tc-counter-ds-8rgfz 1 /1 Running 0 13m go-tc-counter go-tc-counter-ds-gfn8p 1 /1 Running 0 13m go-tc-counter go-tc-counter-ds-x6vkw 1 /1 Running 0 13m go-xdp-counter go-xdp-counter-ds-6px5b 1 /1 Running 0 13m go-xdp-counter go-xdp-counter-ds-ngbj2 1 /1 Running 0 13m go-xdp-counter go-xdp-counter-ds-rhkd4 1 /1 Running 0 13m : You can look at the status field in the bpfprogramconfig to confirm that the program has been loaded successfully: kubectl get bpfprogramconfig NAME AGE go-tc-counter-example 19m go-xdp-counter-example 19m kubectl get bpfprogramconfig go-xdp-counter-example -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgramConfig metadata: creationTimestamp: \"2023-01-12T17:34:30Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: bpfprogramconfig name: go-xdp-counter-example resourceVersion: \"25382\" uid: 2abb3fdd-3712-4dbf-8530-d803012f4e91 spec: attachpoint: networkmultiattach: direction: NONE interface: eth0 priority: 55 bytecode: image://quay.io/bpfd-bytecode/go-xdp-counter:latest name: stats nodeselector: {} type: XDP status: conditions: - lastTransitionTime: \"2023-01-12T17:34:30Z\" message: Waiting for BpfProgramConfig Object to be reconciled to all nodes reason: ProgramsNotYetLoaded status: \"True\" type: NotYetLoaded - lastTransitionTime: \"2023-01-12T17:34:30Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess Both of these programs print statistics to their logs, which can be viewed as follows: kubectl logs -n go-xdp-counter go-xdp-counter-ds-6px5b 2023 /01/12 17 :34:37 mapPath = /run/bpfd/fs/maps/56c8f178-4de2-4012-bec3-6d9abe29e195/xdp_stats_map 2023 /01/12 17 :34:40 4382 packets received 2023 /01/12 17 :34:40 60886324 bytes received 2023 /01/12 17 :34:43 4391 packets received 2023 /01/12 17 :34:43 60904814 bytes received 2023 /01/12 17 :34:46 4402 packets received 2023 /01/12 17 :34:46 60911249 bytes received : API Types Overview BpfProgramConfig The BpfProgramConfig CRD is the bpfd K8s API object most relevant to users and can be used to understand clusterwide state for a BPF program. It's designed to express how, and where BPF programs are to be deployed within a Kubernetes cluster. An example BpfProgramConfig which loads a basic xdp-pass program to all nodes can be seen below: NOTE: Currently the bpfprogram's bytecode section-name MUST match the spec.name field in the BpfProgramConfig Object. apiVersion : bpfd.io/v1alpha1 kind : BpfProgramConfig metadata : labels : app.kubernetes.io/name : BpfProgramConfig name : xdp-pass-all-nodes spec : ## Must correspond to image section name name : pass type : XDP # Select all nodes nodeselector : {} priority : 0 attachpoint : interface : eth0 bytecode : imageurl : quay.io/bpfd-bytecode/xdp_pass:latest BpfProgram The BpfProgram CRD is used internally by the bpfd-deployment to keep track of per node bpfd state such as program UUIDs and map pin points, and to report node specific errors back to the user. K8s users/controllers are only allowed to view these objects, NOT create or edit them. Below is an example BpfProgram Object which was automatically generated in response to the above BpfProgramConfig Object. apiVersion : bpfd.io/v1alpha1 kind : BpfProgram metadata : creationTimestamp : \"2022-12-07T22:41:29Z\" finalizers : - bpfd.io.agent/finalizer generation : 2 labels : owningConfig : xdp-pass-all-nodes name : xdp-pass-all-nodes-bpfd-deployment-worker2 ownerReferences : - apiVersion : bpfd.io/v1alpha1 blockOwnerDeletion : true controller : true kind : BpfProgramConfig name : xdp-pass-all-nodes uid : 6e3f5851-97b1-4772-906b-3ac69c6a4057 resourceVersion : \"1506\" uid : 384d3d5c-e62b-4be3-9bf0-c6cf0e315acf spec : programs : bdeac6d3-4128-464e-9161-6010684eca27 : attachpoint : interface : eth0 maps : {} status : conditions : - lastTransitionTime : \"2022-12-07T22:41:30Z\" message : Successfully loaded BpfProgram reason : bpfdLoaded status : \"True\" type : Loaded Applications wishing to use bpfd to deploy/manage their BPF programs in Kubernetes will make use of this object to find references to the bpfMap pin points ( spec.maps ) in order to configure their BPF programs. Kubectl Plugins Still a work in progress. There are two scripts to help retrieve the BpfProgramConfig and BpfProgram objects in a summary format. The BpfProgramConfig script uses kubectl with -o custom-columns and the BpfProgram script uses kubectl with -o jsonpath . Example of summary of BpfProgramConfigs: kubectl bpfprogramconfigs NAME TYPE SECNAME STATUS INTERFACE PRIORITY DIRECTION TRACEPOINT go-tc-counter-example TC stats ReconcileSuccess eth0 55 INGRESS <none> go-xdp-counter-example XDP stats ReconcileSuccess eth0 55 NONE <none> xdp-pass-all-nodes XDP pass ReconcileSuccess eth0 60 NONE <none> tracepoint-example TRACEPOINT hello ReconcileSuccess <none> <none> <none> sched/sched_switch Example of summary of BpfPrograms: kubectl bpfprograms STATUS REASON NAME IFACE PRI DIR TRACEPOINT Loaded bpfdLoaded go-tc-counter-example-bpfd-deployment-control-plane eth0 55 INGRESS Loaded bpfdLoaded go-tc-counter-example-bpfd-deployment-worker eth0 55 INGRESS Loaded bpfdLoaded go-tc-counter-example-bpfd-deployment-worker2 eth0 55 INGRESS Loaded bpfdLoaded go-xdp-counter-example-bpfd-deployment-control-plane eth0 55 NONE Loaded bpfdLoaded go-xdp-counter-example-bpfd-deployment-worker eth0 55 NONE Loaded bpfdLoaded go-xdp-counter-example-bpfd-deployment-worker2 eth0 55 NONE Loaded bpfdLoaded xdp-pass-all-nodes-bpfd-deployment-control-plane eth0 60 NONE Loaded bpfdLoaded xdp-pass-all-nodes-bpfd-deployment-worker eth0 60 NONE Loaded bpfdLoaded xdp-pass-all-nodes-bpfd-deployment-worker2 eth0 60 NONE To install the kubectl plugins, run: sudo ./scripts/setup.sh kubectl The kubectl plugins will be deleted when uninstall is run: sudo ./scripts/setup.sh uninstall NOTE: ./scripts/setup.sh uninstall removes ALL files installed by bpfd , including any bpfd binaries and service files. Controllers The Bpfd-Operator performs a few major functions and houses two major controllers the bpfd-agent and bpfd-operator . bpfd-agent The bpfd-agent controller is deployed alongside bpfd in a daemonset. It's main purpose is to watch user intent (in BpfProgramConfig Objects) and communicate with bpfd via a mTLS secured connection in order to translate the cluster-wide user-intent to per node state. bpfd-operator The bpfd-operator performs the following functionality: Create and Reconcile the bpfd daemonset (including both the bpfd and bpfd-agent processes) so that no manual edits can be completed. Report cluster wide state back the the user with each BpfProgramConfig's status field. More useful commands Install Instances of Custom Resources: kubectl apply -f config/samples/ Build and push your bpfd-agent and bpd-operator container images to the location specified by BPFD_AGENT_IMG and BPFD_OPERATOR_IMG : make build-images push-images BPFD_OPERATOR_IMG = <some-registry>/bpfd-operator:tag BPFD_AGENT_IMAGE = <some-registry>/bpfd-agent:tag Deploy the operator and agent to a cluster with the image specified by BPFD_AGENT_IMG and BPFD_OPERATOR_IMG : make deploy BPFD_OPERATOR_IMG = <some-registry>/bpfd-operator:tag BPFD_AGENT_IMAGE = <some-registry>/bpfd-agent:tag Reinstall CRDs To delete the CRDs from the cluster: make uninstall Deploy controller Deploy bpfd-operator to the K8s cluster specified in ~/.kube/config: make deploy Undeploy controller Undeploy the controller from a vanilla K8s Deployment cluster: make undeploy Modifying the API definitions If you are editing the API definitions, generate the manifests such as CRs or CRDs using: make manifests","title":"How to Deploy bpfd on Kubernetes"},{"location":"k8s-deployment/#how-to-deploy-bpfd-on-kubernetes","text":"One of the key use cases for bpfd is to support the deployment of BPF programs in Kubernetes clusters. The simplest way to do this is to use the bpfd-operator. In this document, we provide an overview of using the bpfd-operator as well as the manual steps required to use bpfd with Kubernetes, in general, and OpenShift, in particular.","title":"How to Deploy bpfd on Kubernetes"},{"location":"k8s-deployment/#bpfd-operator-overview","text":"The Bpfd-Operator can be used to deploy and manage bpfd within a Kubernetes cluster. The bpfd-operator repository houses two main processes, the bpfd-agent and the bpfd-operator along with CRD api definitions for BpfProgram and BpfProgramConfig Objects. In the below sections we'll dive a bit deeper into the API and functionality of both processes.","title":"bpfd-operator Overview"},{"location":"k8s-deployment/#deployment-options","text":"Choose one of the install options described below, and then go to Verify the installation below to make sure it worked.","title":"Deployment Options"},{"location":"k8s-deployment/#quick-start-with-kind-and-the-bpfd-operator","text":"Using kind with the bpfd-operator is an easy way to spin up a local kind cluster and deploy bpfd.","title":"Quick Start with kind and the bpfd-operator"},{"location":"k8s-deployment/#pre-requsites","text":"Install git , make , and go Install Docker for your platform. We also recommend that you follow the Post-installation steps for Linux to allow your user to run Docker commands without root priviledges. Install kubctl and kind Installation Instructions clone the bpfd repository git clone https://github.com/redhat-et/bpfd.git cd bpfd/bpfd-operator The bpfd-operator was built utilizing some great tooling provided by the operator-sdk library . A great first step in understanding some of the functionality can be to cd into the bpfd/bpfd-operator directory and run make help .","title":"Pre-requsites"},{"location":"k8s-deployment/#deploy-locally-via-kind","text":"After reviewing the possible make targets it's quick and easy to get bpfd deployed locally on your system via a KIND cluster with: make run-on-kind NOTE: You will need a spare 20G in your root partition to run make run-on-kind , and it will take a while the first time you run it. By default local image builds will be used for the kind deployment, however, the container images used for bpfd , bpfd-agent , and bpfd-operator can also be configured as follows. BPFD_IMG = <your/image/url> BPFD_AGENT_IMG = <your/image/url> BPFD_OPERATOR_IMG = <your/image/url> make run-on-kind To push and test out any local changes simply run: make kind-reload-images To tear down the kind cluster, run: kind delete cluster -n bpfd-deployment The default name of the created cluster is bpfd-deployment . To retrieve all the created kind clusters, use kind get clusters","title":"Deploy locally via KIND"},{"location":"k8s-deployment/#deploy-to-openshift-cluster","text":"First install cert-manager (if not already deployed) to the cluster with: make deploy-cert-manager Then deploy the operator with one of the following two options:","title":"Deploy To Openshift Cluster"},{"location":"k8s-deployment/#1-manually-with-kustomize","text":"Then to install manually with Kustomize and raw manifests simply run: make deploy-openshift Which can then be cleaned up with: make undeploy-openshift","title":"1. Manually with Kustomize"},{"location":"k8s-deployment/#2-via-the-olm-bundle","text":"The bpfd-operator can also be installed via it's OLM bundle . First setup the namespace and certificates for the operator with: oc apply -f ./hack/ocp-scc-hacks.yaml Then use operator-sdk to install the bundle like so: operator-sdk run bundle quay.io/bpfd/bpfd-operator-bundle:latest --namespace openshift-bpfd To clean everything up run: operator-sdk cleanup bpfd-operator followed by oc delete -f ./hack/ocp-scc-hacks.yaml","title":"2. Via the OLM bundle"},{"location":"k8s-deployment/#verify-the-installation","text":"NOTE: The commands in this section were run on a local kind deployment. If the bpfd-operator came up successfully you will see the bpfd-daemon and bpfd-operator pods running without errors: kubectl get pods -n bpfd NAME READY STATUS RESTARTS AGE bpfd-daemon-6d4qm 2 /2 Running 0 75m bpfd-daemon-929tf 2 /2 Running 0 75m bpfd-daemon-ftpwn 2 /2 Running 0 75m bpfd-operator-685db895b7-9qqrs 2 /2 Running 0 75m To test the deployment, load one or both of the example programs. NOTE: The example BpfProgramConfig CRDs assume that the programs will be run on eth0 , which is the default for the kind deployment. If you need to run the programs on a different interface, modify interface in the associated file: examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml , or examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml Load the example xdp kernel and user space programs: kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter-bytecode.yaml kubectl create -f examples/go-xdp-counter/kubernetes-deployment/go-xdp-counter.yaml Load the example tc kernel and user space programs: kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter-bytecode.yaml kubectl create -f examples/go-tc-counter/kubernetes-deployment/go-tc-counter.yaml Verify that they are loaded: kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE : go-tc-counter go-tc-counter-ds-8rgfz 1 /1 Running 0 13m go-tc-counter go-tc-counter-ds-gfn8p 1 /1 Running 0 13m go-tc-counter go-tc-counter-ds-x6vkw 1 /1 Running 0 13m go-xdp-counter go-xdp-counter-ds-6px5b 1 /1 Running 0 13m go-xdp-counter go-xdp-counter-ds-ngbj2 1 /1 Running 0 13m go-xdp-counter go-xdp-counter-ds-rhkd4 1 /1 Running 0 13m : You can look at the status field in the bpfprogramconfig to confirm that the program has been loaded successfully: kubectl get bpfprogramconfig NAME AGE go-tc-counter-example 19m go-xdp-counter-example 19m kubectl get bpfprogramconfig go-xdp-counter-example -o yaml apiVersion: bpfd.io/v1alpha1 kind: BpfProgramConfig metadata: creationTimestamp: \"2023-01-12T17:34:30Z\" finalizers: - bpfd.io.operator/finalizer generation: 1 labels: app.kubernetes.io/name: bpfprogramconfig name: go-xdp-counter-example resourceVersion: \"25382\" uid: 2abb3fdd-3712-4dbf-8530-d803012f4e91 spec: attachpoint: networkmultiattach: direction: NONE interface: eth0 priority: 55 bytecode: image://quay.io/bpfd-bytecode/go-xdp-counter:latest name: stats nodeselector: {} type: XDP status: conditions: - lastTransitionTime: \"2023-01-12T17:34:30Z\" message: Waiting for BpfProgramConfig Object to be reconciled to all nodes reason: ProgramsNotYetLoaded status: \"True\" type: NotYetLoaded - lastTransitionTime: \"2023-01-12T17:34:30Z\" message: bpfProgramReconciliation Succeeded on all nodes reason: ReconcileSuccess status: \"True\" type: ReconcileSuccess Both of these programs print statistics to their logs, which can be viewed as follows: kubectl logs -n go-xdp-counter go-xdp-counter-ds-6px5b 2023 /01/12 17 :34:37 mapPath = /run/bpfd/fs/maps/56c8f178-4de2-4012-bec3-6d9abe29e195/xdp_stats_map 2023 /01/12 17 :34:40 4382 packets received 2023 /01/12 17 :34:40 60886324 bytes received 2023 /01/12 17 :34:43 4391 packets received 2023 /01/12 17 :34:43 60904814 bytes received 2023 /01/12 17 :34:46 4402 packets received 2023 /01/12 17 :34:46 60911249 bytes received :","title":"Verify the installation"},{"location":"k8s-deployment/#api-types-overview","text":"","title":"API Types Overview"},{"location":"k8s-deployment/#bpfprogramconfig","text":"The BpfProgramConfig CRD is the bpfd K8s API object most relevant to users and can be used to understand clusterwide state for a BPF program. It's designed to express how, and where BPF programs are to be deployed within a Kubernetes cluster. An example BpfProgramConfig which loads a basic xdp-pass program to all nodes can be seen below: NOTE: Currently the bpfprogram's bytecode section-name MUST match the spec.name field in the BpfProgramConfig Object. apiVersion : bpfd.io/v1alpha1 kind : BpfProgramConfig metadata : labels : app.kubernetes.io/name : BpfProgramConfig name : xdp-pass-all-nodes spec : ## Must correspond to image section name name : pass type : XDP # Select all nodes nodeselector : {} priority : 0 attachpoint : interface : eth0 bytecode : imageurl : quay.io/bpfd-bytecode/xdp_pass:latest","title":"BpfProgramConfig"},{"location":"k8s-deployment/#bpfprogram","text":"The BpfProgram CRD is used internally by the bpfd-deployment to keep track of per node bpfd state such as program UUIDs and map pin points, and to report node specific errors back to the user. K8s users/controllers are only allowed to view these objects, NOT create or edit them. Below is an example BpfProgram Object which was automatically generated in response to the above BpfProgramConfig Object. apiVersion : bpfd.io/v1alpha1 kind : BpfProgram metadata : creationTimestamp : \"2022-12-07T22:41:29Z\" finalizers : - bpfd.io.agent/finalizer generation : 2 labels : owningConfig : xdp-pass-all-nodes name : xdp-pass-all-nodes-bpfd-deployment-worker2 ownerReferences : - apiVersion : bpfd.io/v1alpha1 blockOwnerDeletion : true controller : true kind : BpfProgramConfig name : xdp-pass-all-nodes uid : 6e3f5851-97b1-4772-906b-3ac69c6a4057 resourceVersion : \"1506\" uid : 384d3d5c-e62b-4be3-9bf0-c6cf0e315acf spec : programs : bdeac6d3-4128-464e-9161-6010684eca27 : attachpoint : interface : eth0 maps : {} status : conditions : - lastTransitionTime : \"2022-12-07T22:41:30Z\" message : Successfully loaded BpfProgram reason : bpfdLoaded status : \"True\" type : Loaded Applications wishing to use bpfd to deploy/manage their BPF programs in Kubernetes will make use of this object to find references to the bpfMap pin points ( spec.maps ) in order to configure their BPF programs.","title":"BpfProgram"},{"location":"k8s-deployment/#kubectl-plugins","text":"Still a work in progress. There are two scripts to help retrieve the BpfProgramConfig and BpfProgram objects in a summary format. The BpfProgramConfig script uses kubectl with -o custom-columns and the BpfProgram script uses kubectl with -o jsonpath . Example of summary of BpfProgramConfigs: kubectl bpfprogramconfigs NAME TYPE SECNAME STATUS INTERFACE PRIORITY DIRECTION TRACEPOINT go-tc-counter-example TC stats ReconcileSuccess eth0 55 INGRESS <none> go-xdp-counter-example XDP stats ReconcileSuccess eth0 55 NONE <none> xdp-pass-all-nodes XDP pass ReconcileSuccess eth0 60 NONE <none> tracepoint-example TRACEPOINT hello ReconcileSuccess <none> <none> <none> sched/sched_switch Example of summary of BpfPrograms: kubectl bpfprograms STATUS REASON NAME IFACE PRI DIR TRACEPOINT Loaded bpfdLoaded go-tc-counter-example-bpfd-deployment-control-plane eth0 55 INGRESS Loaded bpfdLoaded go-tc-counter-example-bpfd-deployment-worker eth0 55 INGRESS Loaded bpfdLoaded go-tc-counter-example-bpfd-deployment-worker2 eth0 55 INGRESS Loaded bpfdLoaded go-xdp-counter-example-bpfd-deployment-control-plane eth0 55 NONE Loaded bpfdLoaded go-xdp-counter-example-bpfd-deployment-worker eth0 55 NONE Loaded bpfdLoaded go-xdp-counter-example-bpfd-deployment-worker2 eth0 55 NONE Loaded bpfdLoaded xdp-pass-all-nodes-bpfd-deployment-control-plane eth0 60 NONE Loaded bpfdLoaded xdp-pass-all-nodes-bpfd-deployment-worker eth0 60 NONE Loaded bpfdLoaded xdp-pass-all-nodes-bpfd-deployment-worker2 eth0 60 NONE To install the kubectl plugins, run: sudo ./scripts/setup.sh kubectl The kubectl plugins will be deleted when uninstall is run: sudo ./scripts/setup.sh uninstall NOTE: ./scripts/setup.sh uninstall removes ALL files installed by bpfd , including any bpfd binaries and service files.","title":"Kubectl Plugins"},{"location":"k8s-deployment/#controllers","text":"The Bpfd-Operator performs a few major functions and houses two major controllers the bpfd-agent and bpfd-operator .","title":"Controllers"},{"location":"k8s-deployment/#bpfd-agent","text":"The bpfd-agent controller is deployed alongside bpfd in a daemonset. It's main purpose is to watch user intent (in BpfProgramConfig Objects) and communicate with bpfd via a mTLS secured connection in order to translate the cluster-wide user-intent to per node state.","title":"bpfd-agent"},{"location":"k8s-deployment/#bpfd-operator","text":"The bpfd-operator performs the following functionality: Create and Reconcile the bpfd daemonset (including both the bpfd and bpfd-agent processes) so that no manual edits can be completed. Report cluster wide state back the the user with each BpfProgramConfig's status field.","title":"bpfd-operator"},{"location":"k8s-deployment/#more-useful-commands","text":"Install Instances of Custom Resources: kubectl apply -f config/samples/ Build and push your bpfd-agent and bpd-operator container images to the location specified by BPFD_AGENT_IMG and BPFD_OPERATOR_IMG : make build-images push-images BPFD_OPERATOR_IMG = <some-registry>/bpfd-operator:tag BPFD_AGENT_IMAGE = <some-registry>/bpfd-agent:tag Deploy the operator and agent to a cluster with the image specified by BPFD_AGENT_IMG and BPFD_OPERATOR_IMG : make deploy BPFD_OPERATOR_IMG = <some-registry>/bpfd-operator:tag BPFD_AGENT_IMAGE = <some-registry>/bpfd-agent:tag","title":"More useful commands"},{"location":"k8s-deployment/#reinstall-crds","text":"To delete the CRDs from the cluster: make uninstall","title":"Reinstall CRDs"},{"location":"k8s-deployment/#deploy-controller","text":"Deploy bpfd-operator to the K8s cluster specified in ~/.kube/config: make deploy","title":"Deploy controller"},{"location":"k8s-deployment/#undeploy-controller","text":"Undeploy the controller from a vanilla K8s Deployment cluster: make undeploy","title":"Undeploy controller"},{"location":"k8s-deployment/#modifying-the-api-definitions","text":"If you are editing the API definitions, generate the manifests such as CRs or CRDs using: make manifests","title":"Modifying the API definitions"},{"location":"linux-capabilities/","text":"Linux Capabilities Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute. See capabilities man-page . When bpfd is run as a systemd service, the set of linux capabilities are restricted to only the required set of capabilities via the bpfd.service file using the AmbientCapabilities and CapabilityBoundingSet fields (see bpfd.service ). All spawned threads are stripped of all capabilities, removing all sudo privileges (see drop_linux_capabilities() usage), leaving only the main thread with only the needed set of capabilities. Debugging Linux Capabilities As new features are added, the set of Linux capabilities required by bpfd may change over time. The following describes the steps to determine the set of capabilities required by bpfd. If there are any Permission denied (os error 13) type errors when starting or running bpfd as a systemd service, adjusting the linux capabilities is a good place to start. Determine Required Capabilities The first step is to turn all capabilities on and see if that fixes the problem. This can be done without recompiling the code by editing bpfd.service . Comment out the finite list of granted capabilities and set to ~ , which indicates all capabilities. sudo vi /usr/lib/systemd/system/bpfd.service : [ Service ] : AmbientCapabilities = ~ CapabilityBoundingSet = ~ #AmbientCapabilities=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE #CapabilityBoundingSet=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE Reload the service file and start/restart bpfd and watch the bpfd logs and see if the problem is resolved: sudo systemctl daemon-reload sudo systemctl start bpfd If so, then the next step is to watch the set of capabilities being requested by bpfd. Run the bcc capable tool to watch capabilities being requested real-time and restart bpfd: $ sudo /usr/share/bcc/tools/capable TIME UID PID COMM CAP NAME AUDIT : 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 979 75550 bpfd 24 CAP_SYS_RESOURCE 1 16 :36:00 979 75550 bpfd 1 CAP_DAC_OVERRIDE 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 0 75555 modprobe 16 CAP_SYS_MODULE 1 16 :36:00 0 628 systemd-udevd 2 CAP_DAC_READ_SEARCH 1 16 :36:00 0 75556 bpf_preload 24 CAP_SYS_RESOURCE 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 : Compare the output to list in bpfd.service and determine the delta. Determine Capabilities Per Thread For additional debugging, it may be helpful to know the granted capabilities on a per thread basis. As mentioned above, all spawned threads are stripped of all Linux capabilities, so if a thread is requesting a capability, that functionality should be moved off the spawned thread and onto the main thread. First, determine the bpfd process id, then determine the set of threads: $ ps -ef | grep bpfd : bpfd 75550 1 0 16 :36 ? 00 :00:00 /usr/sbin/bpfd : $ ps -T -p 75550 PID SPID TTY TIME CMD 75550 75550 ? 00 :00:00 bpfd 75550 75551 ? 00 :00:00 tokio-runtime-w 75550 75552 ? 00 :00:00 tokio-runtime-w 75550 75553 ? 00 :00:00 tokio-runtime-w 75550 75554 ? 00 :00:00 tokio-runtime-w Then dump the capabilities of each thread: $ grep Cap /proc/75550/status CapInh: 000000c001201106 CapPrm: 000000c001201106 CapEff: 000000c001201106 CapBnd: 000000c001201106 CapAmb: 000000c001201106 $ grep Cap /proc/75551/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 $ grep Cap /proc/75552/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 : $ capsh --decode=000000c001201106 0x000000c001201106=cap_dac_override,cap_dac_read_search,cap_setpcap,cap_net_admin,cap_sys_admin,cap_sys_resource,cap_perfmon,cap_bpf","title":"Linux Capabilities"},{"location":"linux-capabilities/#linux-capabilities","text":"Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute. See capabilities man-page . When bpfd is run as a systemd service, the set of linux capabilities are restricted to only the required set of capabilities via the bpfd.service file using the AmbientCapabilities and CapabilityBoundingSet fields (see bpfd.service ). All spawned threads are stripped of all capabilities, removing all sudo privileges (see drop_linux_capabilities() usage), leaving only the main thread with only the needed set of capabilities.","title":"Linux Capabilities"},{"location":"linux-capabilities/#debugging-linux-capabilities","text":"As new features are added, the set of Linux capabilities required by bpfd may change over time. The following describes the steps to determine the set of capabilities required by bpfd. If there are any Permission denied (os error 13) type errors when starting or running bpfd as a systemd service, adjusting the linux capabilities is a good place to start.","title":"Debugging Linux Capabilities"},{"location":"linux-capabilities/#determine-required-capabilities","text":"The first step is to turn all capabilities on and see if that fixes the problem. This can be done without recompiling the code by editing bpfd.service . Comment out the finite list of granted capabilities and set to ~ , which indicates all capabilities. sudo vi /usr/lib/systemd/system/bpfd.service : [ Service ] : AmbientCapabilities = ~ CapabilityBoundingSet = ~ #AmbientCapabilities=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE #CapabilityBoundingSet=CAP_BPF CAP_DAC_OVERRIDE CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SETPCAP CAP_SYS_ADMIN CAP_SYS_RESOURCE Reload the service file and start/restart bpfd and watch the bpfd logs and see if the problem is resolved: sudo systemctl daemon-reload sudo systemctl start bpfd If so, then the next step is to watch the set of capabilities being requested by bpfd. Run the bcc capable tool to watch capabilities being requested real-time and restart bpfd: $ sudo /usr/share/bcc/tools/capable TIME UID PID COMM CAP NAME AUDIT : 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 979 75553 tokio-runtime-w 8 CAP_SETPCAP 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 0 616 systemd-journal 19 CAP_SYS_PTRACE 1 16 :36:00 979 75550 bpfd 24 CAP_SYS_RESOURCE 1 16 :36:00 979 75550 bpfd 1 CAP_DAC_OVERRIDE 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 979 75550 bpfd 21 CAP_SYS_ADMIN 1 16 :36:00 0 75555 modprobe 16 CAP_SYS_MODULE 1 16 :36:00 0 628 systemd-udevd 2 CAP_DAC_READ_SEARCH 1 16 :36:00 0 75556 bpf_preload 24 CAP_SYS_RESOURCE 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 39 CAP_BPF 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 16 :36:00 0 75556 bpf_preload 38 CAP_PERFMON 1 : Compare the output to list in bpfd.service and determine the delta.","title":"Determine Required Capabilities"},{"location":"linux-capabilities/#determine-capabilities-per-thread","text":"For additional debugging, it may be helpful to know the granted capabilities on a per thread basis. As mentioned above, all spawned threads are stripped of all Linux capabilities, so if a thread is requesting a capability, that functionality should be moved off the spawned thread and onto the main thread. First, determine the bpfd process id, then determine the set of threads: $ ps -ef | grep bpfd : bpfd 75550 1 0 16 :36 ? 00 :00:00 /usr/sbin/bpfd : $ ps -T -p 75550 PID SPID TTY TIME CMD 75550 75550 ? 00 :00:00 bpfd 75550 75551 ? 00 :00:00 tokio-runtime-w 75550 75552 ? 00 :00:00 tokio-runtime-w 75550 75553 ? 00 :00:00 tokio-runtime-w 75550 75554 ? 00 :00:00 tokio-runtime-w Then dump the capabilities of each thread: $ grep Cap /proc/75550/status CapInh: 000000c001201106 CapPrm: 000000c001201106 CapEff: 000000c001201106 CapBnd: 000000c001201106 CapAmb: 000000c001201106 $ grep Cap /proc/75551/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 $ grep Cap /proc/75552/status CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 0000000000000000 CapAmb: 0000000000000000 : $ capsh --decode=000000c001201106 0x000000c001201106=cap_dac_override,cap_dac_read_search,cap_setpcap,cap_net_admin,cap_sys_admin,cap_sys_resource,cap_perfmon,cap_bpf","title":"Determine Capabilities Per Thread"},{"location":"shipping-bytecode/","text":"EBPF Bytecode Image Specifications Introduction The EBPF Bytecode Image specification defines how to package EBPF bytecode as container images. The initial primary use case focuses on the containerization and deployment of EBPF programs within container orchestration systems such as Kubernetes, where it is necessary to provide a portable way to distribute bytecode to all nodes which need it. Specifications We provide two distinct spec variants here to ensure interoperatiblity with existing registries and packages which do no support the new custom media types defined here. custom-data-type-spec backwards-compatable-spec Backwards compatible OCI compliant spec This variant makes use of existing OCI conventions to represent EBPF Bytecode as container images. Image Layers The container images following this variant must contain exactly one layer who's media type is one of the following: application/vnd.oci.image.layer.v1.tar+gzip or the compliant application/vnd.docker.image.rootfs.diff.tar.gzip Additionally the image layer must contain a valid EBPF object file (generally containing a .o extension) placed at the root of the layer ./ . Image Labels To provide relevant metadata regarding the bytecode to any consumers, some relevant labels MUST be defined on the image. These labels are defined as follows: io.ebpf.program_type : The EBPF program type (i.e xdp , tc , sockops , ...). io.ebpf.filename : The Filename of the bytecode stored in the image. io.ebpf.program_name : The name of the EBPF Program represented in the bytecode. io.ebpf.section_name : The section name of the EBPF Program. io.ebpf.kernel_version : The Kernel version for which this bytecode was compiled against. Building a Backwards compatible OCI compliant image An Example Containerfile can be found at /packaging/container/deployment/Containerfile.bytecode To use the provided templated Containerfile simply run a docker build command like the following: docker build \\ --build-arg PROGRAM_NAME = xdp_pass \\ --build-arg SECTION_NAME = pass \\ --build-arg PROGRAM_TYPE = xdp \\ --build-arg BYTECODE_FILENAME = pass.bpf.o \\ --build-arg KERNEL_COMPILE_VER = $( uname -r ) \\ -f packaging/container-deployment/Containerfile.bytecode \\ /home/<USER>/bytecode -t quay.io/<USER>/xdp_pass:latest Where /home/<USER>/bytecode is the directory the bytecode object file is located. Users can also use skopeo to ensure the image follows the backwards compatible version of the spec: skopeo inspect will show the correctly configured labels stored in the configuration layer ( application/vnd.oci.image.config.v1+json ) of the image. skopeo inspect docker://quay.io/astoycos/xdp_pass:latest { \"Name\" : \"quay.io/<USER>/xdp_pass\" , \"Digest\" : \"sha256:db1f7dd03f9fba0913e07493238fcfaf0bf08de37b8e992cc5902775dfb9086a\" , \"RepoTags\" : [ \"latest\" ] , \"Created\" : \"2022-08-14T14:27:20.147468277Z\" , \"DockerVersion\" : \"\" , \"Labels\" : { \"io.buildah.version\" : \"1.26.1\" , \"io.ebpf.filename\" : \"pass.bpf.o\" , \"io.ebpf.kernel_version\" : \"5.18.6-200.fc36.x86_64\" , \"io.ebpf.program_name\" : \"xdp_counter\" , \"io.ebpf.program_type\" : \"xdp\" , \"io.ebpf.section_name\" : \"pass\" } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Layers\" : [ \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" ] , \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } skopeo inspect --raw will show the correct layer type is used in the image. skopeo inspect --raw docker://quay.io/astoycos/xdp_pass:latest { \"schemaVersion\" :2, \"mediaType\" : \"application/vnd.oci.image.manifest.v1+json\" , \"config\" : { \"mediaType\" : \"application/vnd.oci.image.config.v1+json\" , \"digest\" : \"sha256:ff4108b8405a877b2df3e06f9287c509b9d62d6c241c9a5213d81a9abee80361\" , \"size\" :2385 } , \"layers\" : [{ \"mediaType\" : \"application/vnd.oci.image.layer.v1.tar+gzip\" , \"digest\" : \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" , \"size\" :1539 }] , \"annotations\" : { \"org.opencontainers.image.base.digest\" : \"sha256:86b59a6cf7046c624c47e40a5618b383d763be712df2c0e7aaf9391c2c9ef559\" , \"org.opencontainers.image.base.name\" : \"\" }} Custom OCI compatible spec This variant of the EBPF bytecode image spec uses custom OCI medium types to represent EBPF bytecode as container images. Many toolchains and registries may not support this yet. TODO(astoycos)","title":"EBPF Bytecode Image Specifications"},{"location":"shipping-bytecode/#ebpf-bytecode-image-specifications","text":"","title":"EBPF Bytecode Image Specifications"},{"location":"shipping-bytecode/#introduction","text":"The EBPF Bytecode Image specification defines how to package EBPF bytecode as container images. The initial primary use case focuses on the containerization and deployment of EBPF programs within container orchestration systems such as Kubernetes, where it is necessary to provide a portable way to distribute bytecode to all nodes which need it.","title":"Introduction"},{"location":"shipping-bytecode/#specifications","text":"We provide two distinct spec variants here to ensure interoperatiblity with existing registries and packages which do no support the new custom media types defined here. custom-data-type-spec backwards-compatable-spec","title":"Specifications"},{"location":"shipping-bytecode/#backwards-compatible-oci-compliant-spec","text":"This variant makes use of existing OCI conventions to represent EBPF Bytecode as container images.","title":"Backwards compatible OCI compliant spec"},{"location":"shipping-bytecode/#image-layers","text":"The container images following this variant must contain exactly one layer who's media type is one of the following: application/vnd.oci.image.layer.v1.tar+gzip or the compliant application/vnd.docker.image.rootfs.diff.tar.gzip Additionally the image layer must contain a valid EBPF object file (generally containing a .o extension) placed at the root of the layer ./ .","title":"Image Layers"},{"location":"shipping-bytecode/#image-labels","text":"To provide relevant metadata regarding the bytecode to any consumers, some relevant labels MUST be defined on the image. These labels are defined as follows: io.ebpf.program_type : The EBPF program type (i.e xdp , tc , sockops , ...). io.ebpf.filename : The Filename of the bytecode stored in the image. io.ebpf.program_name : The name of the EBPF Program represented in the bytecode. io.ebpf.section_name : The section name of the EBPF Program. io.ebpf.kernel_version : The Kernel version for which this bytecode was compiled against.","title":"Image Labels"},{"location":"shipping-bytecode/#building-a-backwards-compatible-oci-compliant-image","text":"An Example Containerfile can be found at /packaging/container/deployment/Containerfile.bytecode To use the provided templated Containerfile simply run a docker build command like the following: docker build \\ --build-arg PROGRAM_NAME = xdp_pass \\ --build-arg SECTION_NAME = pass \\ --build-arg PROGRAM_TYPE = xdp \\ --build-arg BYTECODE_FILENAME = pass.bpf.o \\ --build-arg KERNEL_COMPILE_VER = $( uname -r ) \\ -f packaging/container-deployment/Containerfile.bytecode \\ /home/<USER>/bytecode -t quay.io/<USER>/xdp_pass:latest Where /home/<USER>/bytecode is the directory the bytecode object file is located. Users can also use skopeo to ensure the image follows the backwards compatible version of the spec: skopeo inspect will show the correctly configured labels stored in the configuration layer ( application/vnd.oci.image.config.v1+json ) of the image. skopeo inspect docker://quay.io/astoycos/xdp_pass:latest { \"Name\" : \"quay.io/<USER>/xdp_pass\" , \"Digest\" : \"sha256:db1f7dd03f9fba0913e07493238fcfaf0bf08de37b8e992cc5902775dfb9086a\" , \"RepoTags\" : [ \"latest\" ] , \"Created\" : \"2022-08-14T14:27:20.147468277Z\" , \"DockerVersion\" : \"\" , \"Labels\" : { \"io.buildah.version\" : \"1.26.1\" , \"io.ebpf.filename\" : \"pass.bpf.o\" , \"io.ebpf.kernel_version\" : \"5.18.6-200.fc36.x86_64\" , \"io.ebpf.program_name\" : \"xdp_counter\" , \"io.ebpf.program_type\" : \"xdp\" , \"io.ebpf.section_name\" : \"pass\" } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Layers\" : [ \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" ] , \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } skopeo inspect --raw will show the correct layer type is used in the image. skopeo inspect --raw docker://quay.io/astoycos/xdp_pass:latest { \"schemaVersion\" :2, \"mediaType\" : \"application/vnd.oci.image.manifest.v1+json\" , \"config\" : { \"mediaType\" : \"application/vnd.oci.image.config.v1+json\" , \"digest\" : \"sha256:ff4108b8405a877b2df3e06f9287c509b9d62d6c241c9a5213d81a9abee80361\" , \"size\" :2385 } , \"layers\" : [{ \"mediaType\" : \"application/vnd.oci.image.layer.v1.tar+gzip\" , \"digest\" : \"sha256:5f6dae6f567601fdad15a936d844baac1f30c31bd3df8df0c5b5429f3e048000\" , \"size\" :1539 }] , \"annotations\" : { \"org.opencontainers.image.base.digest\" : \"sha256:86b59a6cf7046c624c47e40a5618b383d763be712df2c0e7aaf9391c2c9ef559\" , \"org.opencontainers.image.base.name\" : \"\" }}","title":"Building a Backwards compatible OCI compliant image"},{"location":"shipping-bytecode/#custom-oci-compatible-spec","text":"This variant of the EBPF bytecode image spec uses custom OCI medium types to represent EBPF bytecode as container images. Many toolchains and registries may not support this yet. TODO(astoycos)","title":"Custom OCI compatible spec"},{"location":"tutorial/","text":"Tutorial This tutorial will show you how to use bpfd . There are several ways to launch and interact with bpfd and bpfctl : Privileged Mode - Run bpfd in foreground or background and straight from build directory. bpfd user is not created so sudo is always required when executing bpfctl commands. See Privileged Mode . Systemd Service - Run bpfd as a systemd service as the bpfd user. See Systemd Service . Privileged Mode Step 0: Prerequisites This tutorial uses examples from the xdp-tutorial . Use either pre-built container images from https://quay.io/organization/bpfd-bytecode or check out the xdp-tutorial git repository and compile the examples. EBPF Bytecode Image Specifications describes how BPF bytecode is packaged in container images. Step 1: Build bpfd Perform the following steps to build bpfd . If this is your first time using bpfd, follow the instructions in Setup and Building bpfd to setup the prerequisites for building. cd $HOME/src/bpfd/ cargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf cargo build Step 2: Setup bpfd environment bpfd uses mTLS for mutual authentication with clients. In order to run and interact with bpfd , certificates must be created. If no local certificate authority exists when bpfd is started, it will automatically be created. For this tutorial, bpfd will create the certificate authority in /etc/bpfd/certs/ . Step 3: Start bpfd While learning and experimenting with bpfd , it may be useful to run bpfd in the foreground (which requires a second terminal to run the bpfctl commands below). For more details on how logging is handled in bpfd, see Logging below. sudo RUST_LOG=info ./target/debug/bpfd Later, once familiar with bpfd, optionally run in the background instead: sudo ./target/debug/bpfd& Step 4: Load your first program We will load the simple xdp-pass program, which permits all traffic to the attached interface, vethb2795c7 in this example. The section in the object file that contains the program is \"xdp\". Finally, we will use the priority of 100 (valid values are from 0 to 255). Find a deeper dive into bpfctl syntax in bpfctl below. sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl returns a unique identifier ( 92e3e14c-0400-4a20-be2d-f701af21873c in this example) to the program that was loaded. This may be used to detach the program later. We can check the program was loaded using the following command: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } From the output above you can see the program was loaded to position 0 on our interface and will be executed first. Step 5: Loading more programs We will now load 2 more programs with different priorities to demonstrate how bpfd will ensure they are ordered correctly: sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 50 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 200 6af7c28f-6a7f-46ee-bc98-2d92ed261369 Using bpfctl list we can see that the programs are correctly ordered. The lowest priority program is executed first, while the highest is executed last. sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 50, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 1, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 200, \"iface\": \"vethb2795c7\", \"position\": 2, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } By default, the next program in the chain will only be executed if a given program returns pass (see proceed-on field in the bpfctl list output above). If the next program in the chain should be called even if a different value is returned, then the program can be loaded with those additional return values using the proceed-on parameter (see bpfctl help load for list of valid values): sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 150 --proceed-on \"pass\" --proceed-on \"dispatcher_return\" b2f19b7b-4c71-4338-873e-914bd8fa44ba Which results in (see position 2): sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 50, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 150, \"iface\": \"vethb2795c7\", \"position\": 2, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 200, \"iface\": \"vethb2795c7\", \"position\": 3, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 1, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } Note that the list of programs may not always be sorted in the order of execution. The position indicates the order of execution, low to high. Step 6: Delete a program Let's remove the program at position 1. sudo ./target/debug/bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c And we can verify that it has been removed and the other programs re-ordered: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 50, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 150, \"iface\": \"vethb2795c7\", \"position\": 1, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 200, \"iface\": \"vethb2795c7\", \"position\": 2, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } When bpfd is stopped, all remaining programs will be unloaded automatically. Step 7: Clean-up To unwind all the changes, stop bpfd and then run the following script: sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed. Systemd Service To run bpfd as a systemd service, the binaries will be placed in a well known location ( /usr/sbin/. ) and a service configuration file will be added ( /usr/lib/systemd/system/bpfd.service ). When run as a systemd service, the set of linux capabilities are limited to only the needed set. If permission errors are encountered, see Linux Capabilities for help debugging. Step 0-1 Same as above. Step 2: Setup bpfd environment Run the following command to copy the bpfd and bpfctl binaries to /usr/sbin/. and set the user and user group for each, and copy a default bpfd.service file to /usr/lib/systemd/system/ . This option will also start the systemd service bpfd.service by default: sudo ./scripts/setup.sh install Then add usergroup bpfd to desired user if not already run and logout/login to apply: sudo usermod -a -G bpfd $USER exit <LOGIN> To update the configuration settings associated with running bpfd as a service, edit the service configuration file: sudo vi /usr/lib/systemd/system/bpfd.service sudo systemctl daemon-reload If bpfd or bpfctl is rebuilt, the following command can be run to install the update binaries without tearing down the users and regenerating the certifications. The bpfd service will is automatically restarted. sudo ./scripts/setup.sh reinstall Step 3: Start bpfd To manage bpfd as a systemd service, use systemctl . sudo ./scripts/setup.sh install will start the service, but the service can be manually stopped and started: sudo systemctl stop bpfd.service ... sudo systemctl start bpfd.service Step 4-6 Same as above except sudo can be dropped from all the bpfctl commands and bpfctl is now in $PATH: bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c Step 7: Clean-up To unwind all the changes performed while running bpfd as a systemd service, run the following script. This command cleans up everything, including stopping the bpfd service if it is still running. sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed. bpfctl bpfctl is the command line tool for interacting with bpfd . bpfctl allows the user to load , unload and list bpf programs. Basic syntax: bpfctl --help A client for working with bpfd Usage: bpfctl <COMMAND> Commands: load unload list help Print this message or the help of the given subcommand(s) Options: -h, --help Print help information -V, --version Print version information bpfctl load The bpfctl load command is used to load bpf programs. Each program type (i.e. <COMMAND> ) has it's own set of attributes specific to the program type, and those attributes MUST come after the program type is entered. There are a common set of attributes, and those MUST come before the program type is entered. bpfctl load --help Usage: bpfctl load [OPTIONS] --location <LOCATION> <COMMAND> Commands: xdp tc tracepoint help Print this message or the help of the given subcommand(s) Options: -s, --section-name <SECTION_NAME> Required if \"--from-image\" is not present: Name of the ELF section from the object file [default: ] -l, --location <LOCATION> Required: Location of Program Bytecode to load. Either Local file (file:///<path>) or bytecode image URL (image://<container image url>) -h, --help Print help Example loading from local file: bpfctl load --location file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 100 Example from image in remote repository (Note: --section-name is built into the image and is not required): bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 Command specific help is also provided: bpfctl load xdp --help Usage: bpfctl load --location <LOCATION> xdp [OPTIONS] --iface <IFACE> --priority <PRIORITY> Options: -i, --iface <IFACE> Required: Interface to load program on --priority <PRIORITY> Required: Priority to run program in chain. Lower value runs first --proceed-on <PROCEED_ON>... Optional: Proceed to call other programs in chain on this exit code. Multiple values supported by repeating the parameter. Possible values: [aborted, drop, pass, tx, redirect, dispatcher_return] Default values: pass and dispatcher_return -h, --help Print help bpfctl load Examples Below are some examples of bpfctl load commands: bpfctl load --location file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 35 bpfctl load --location file:///usr/local/src/net-ebpf-playground/.output/filter.bpf.o --section-name classifier tc --direction ingress --iface vethb2795c7 --priority 110 bpfctl load --location image://quay.io/bpfd-bytecode/tracepoint:latest tracepoint --tracepoint sched/sched_switch bpfctl list The bpfctl list command lists all the loaded bpf programs: bpfctl list UUID Type Name Location Metadata c22440a7-5511-4c59-9cad-50583d0dbb3f tc-0 classifier file:///usr/local/src/net-ebpf-playground/.output/filter.bpf.o { \"priority\": 110, \"iface\": \"vethb2795c7\", \"postiion\": 0 } 6dafc471-a05c-469e-a066-0d2fbba8f19d xdp xdp file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o { \"priority\": 35, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } e46e9de9-321b-4d91-b7c5-426f4357402d tracepoint hello image://quay.io/bpfd-bytecode/tracepoint:latest { \"tracepoint\": sched/sched_switch } bpfctl unload The bpfctl unload command takes the UUID from the load or list command as a parameter, and unloads the requested bpf program: bpfctl unload c22440a7-5511-4c59-9cad-50583d0dbb3f bpfctl list UUID Type Name Location Metadata 6dafc471-a05c-469e-a066-0d2fbba8f19d xdp xdp file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o { \"priority\": 35, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } e46e9de9-321b-4d91-b7c5-426f4357402d tracepoint hello image://quay.io/bpfd-bytecode/tracepoint:latest { \"tracepoint\": sched/sched_switch } Logging env_logger bpfd and bpfctl use the env_logger crate to log messages to the terminal. By default, only error messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. Valid values: error warn info debug trace Example: $ sudo RUST_LOG = info /usr/local/bin/bpfd [2022-08-08T20:29:31Z INFO bpfd] Log using env_logger [2022-08-08T20:29:31Z INFO bpfd::server] Loading static programs from /etc/bpfd/programs.d [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Map veth12fa8e3 to 13 [2022-08-08T20:29:31Z INFO bpfd::server] Listening on [::1]:50051 [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Program added: 1 programs attached to veth12fa8e3 [2022-08-08T20:29:31Z INFO bpfd::server] Loaded static program pass with UUID d9fd88df-d039-4e64-9f63-19f3e08915ce bpfctl doesn't currently have any logs, but the infrastructure is in place if needed for future debugging. Systemd Service If bpfd is running as a systemd service, then bpfd will log to journald. As with env_logger, by default, only error messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. bpfctl won't be run as a service, so it always uses env_logger. Example: sudo vi /usr/lib/systemd/system/bpfd.service [Unit] Description=Run bpfd as a service DefaultDependencies=no After=network.target [Service] Environment=\"RUST_LOG=Info\" <==== Set Log Level Here ExecStart=/usr/sbin/bpfd MemoryAccounting=true MemoryLow=infinity MemoryMax=infinity User=bpfd Group=bpfd AmbientCapabilities=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE CapabilityBoundingSet=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE Start the service: sudo systemctl start bpfd.service Check the logs: $ sudo journalctl -f -u bpfd Aug 08 16:25:04 ebpf03 systemd[1]: Started bpfd.service - Run bpfd as a service. Aug 08 16:25:04 ebpf03 bpfd[180118]: Log using journald Aug 08 16:25:04 ebpf03 bpfd[180118]: Loading static programs from /etc/bpfd/programs.d Aug 08 16:25:04 ebpf03 bpfd[180118]: Map veth12fa8e3 to 13 Aug 08 16:25:04 ebpf03 bpfd[180118]: Listening on [::1]:50051 Aug 08 16:25:04 ebpf03 bpfd[180118]: Program added: 1 programs attached to veth12fa8e3 Aug 08 16:25:04 ebpf03 bpfd[180118]: Loaded static program pass with UUID a3ffa14a-786d-48ad-b0cd-a4802f0f10b6 Stop the service: sudo systemctl stop bpfd.service","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This tutorial will show you how to use bpfd . There are several ways to launch and interact with bpfd and bpfctl : Privileged Mode - Run bpfd in foreground or background and straight from build directory. bpfd user is not created so sudo is always required when executing bpfctl commands. See Privileged Mode . Systemd Service - Run bpfd as a systemd service as the bpfd user. See Systemd Service .","title":"Tutorial"},{"location":"tutorial/#privileged-mode","text":"","title":"Privileged Mode"},{"location":"tutorial/#step-0-prerequisites","text":"This tutorial uses examples from the xdp-tutorial . Use either pre-built container images from https://quay.io/organization/bpfd-bytecode or check out the xdp-tutorial git repository and compile the examples. EBPF Bytecode Image Specifications describes how BPF bytecode is packaged in container images.","title":"Step 0: Prerequisites"},{"location":"tutorial/#step-1-build-bpfd","text":"Perform the following steps to build bpfd . If this is your first time using bpfd, follow the instructions in Setup and Building bpfd to setup the prerequisites for building. cd $HOME/src/bpfd/ cargo xtask build-ebpf --libbpf-dir $HOME/src/libbpf cargo build","title":"Step 1: Build bpfd"},{"location":"tutorial/#step-2-setup-bpfd-environment","text":"bpfd uses mTLS for mutual authentication with clients. In order to run and interact with bpfd , certificates must be created. If no local certificate authority exists when bpfd is started, it will automatically be created. For this tutorial, bpfd will create the certificate authority in /etc/bpfd/certs/ .","title":"Step 2: Setup bpfd environment"},{"location":"tutorial/#step-3-start-bpfd","text":"While learning and experimenting with bpfd , it may be useful to run bpfd in the foreground (which requires a second terminal to run the bpfctl commands below). For more details on how logging is handled in bpfd, see Logging below. sudo RUST_LOG=info ./target/debug/bpfd Later, once familiar with bpfd, optionally run in the background instead: sudo ./target/debug/bpfd&","title":"Step 3: Start bpfd"},{"location":"tutorial/#step-4-load-your-first-program","text":"We will load the simple xdp-pass program, which permits all traffic to the attached interface, vethb2795c7 in this example. The section in the object file that contains the program is \"xdp\". Finally, we will use the priority of 100 (valid values are from 0 to 255). Find a deeper dive into bpfctl syntax in bpfctl below. sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl returns a unique identifier ( 92e3e14c-0400-4a20-be2d-f701af21873c in this example) to the program that was loaded. This may be used to detach the program later. We can check the program was loaded using the following command: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } From the output above you can see the program was loaded to position 0 on our interface and will be executed first.","title":"Step 4: Load your first program"},{"location":"tutorial/#step-5-loading-more-programs","text":"We will now load 2 more programs with different priorities to demonstrate how bpfd will ensure they are ordered correctly: sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 50 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 200 6af7c28f-6a7f-46ee-bc98-2d92ed261369 Using bpfctl list we can see that the programs are correctly ordered. The lowest priority program is executed first, while the highest is executed last. sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 50, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 1, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 200, \"iface\": \"vethb2795c7\", \"position\": 2, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } By default, the next program in the chain will only be executed if a given program returns pass (see proceed-on field in the bpfctl list output above). If the next program in the chain should be called even if a different value is returned, then the program can be loaded with those additional return values using the proceed-on parameter (see bpfctl help load for list of valid values): sudo ./target/debug/bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 150 --proceed-on \"pass\" --proceed-on \"dispatcher_return\" b2f19b7b-4c71-4338-873e-914bd8fa44ba Which results in (see position 2): sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 50, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 150, \"iface\": \"vethb2795c7\", \"position\": 2, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 200, \"iface\": \"vethb2795c7\", \"position\": 3, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 1, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } Note that the list of programs may not always be sorted in the order of execution. The position indicates the order of execution, low to high.","title":"Step 5: Loading more programs"},{"location":"tutorial/#step-6-delete-a-program","text":"Let's remove the program at position 1. sudo ./target/debug/bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c And we can verify that it has been removed and the other programs re-ordered: sudo ./target/debug/bpfctl list UUID Type Name Location Metadata 1ccc1376-60e8-4dc5-9079-6c32748fa1c4 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 50, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } b2f19b7b-4c71-4338-873e-914bd8fa44ba xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 150, \"iface\": \"vethb2795c7\", \"position\": 1, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } 6af7c28f-6a7f-46ee-bc98-2d92ed261369 xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 200, \"iface\": \"vethb2795c7\", \"position\": 2, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } When bpfd is stopped, all remaining programs will be unloaded automatically.","title":"Step 6: Delete a program"},{"location":"tutorial/#step-7-clean-up","text":"To unwind all the changes, stop bpfd and then run the following script: sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed.","title":"Step 7: Clean-up"},{"location":"tutorial/#systemd-service","text":"To run bpfd as a systemd service, the binaries will be placed in a well known location ( /usr/sbin/. ) and a service configuration file will be added ( /usr/lib/systemd/system/bpfd.service ). When run as a systemd service, the set of linux capabilities are limited to only the needed set. If permission errors are encountered, see Linux Capabilities for help debugging.","title":"Systemd Service"},{"location":"tutorial/#step-0-1","text":"Same as above.","title":"Step 0-1"},{"location":"tutorial/#step-2-setup-bpfd-environment_1","text":"Run the following command to copy the bpfd and bpfctl binaries to /usr/sbin/. and set the user and user group for each, and copy a default bpfd.service file to /usr/lib/systemd/system/ . This option will also start the systemd service bpfd.service by default: sudo ./scripts/setup.sh install Then add usergroup bpfd to desired user if not already run and logout/login to apply: sudo usermod -a -G bpfd $USER exit <LOGIN> To update the configuration settings associated with running bpfd as a service, edit the service configuration file: sudo vi /usr/lib/systemd/system/bpfd.service sudo systemctl daemon-reload If bpfd or bpfctl is rebuilt, the following command can be run to install the update binaries without tearing down the users and regenerating the certifications. The bpfd service will is automatically restarted. sudo ./scripts/setup.sh reinstall","title":"Step 2: Setup bpfd environment"},{"location":"tutorial/#step-3-start-bpfd_1","text":"To manage bpfd as a systemd service, use systemctl . sudo ./scripts/setup.sh install will start the service, but the service can be manually stopped and started: sudo systemctl stop bpfd.service ... sudo systemctl start bpfd.service","title":"Step 3: Start bpfd"},{"location":"tutorial/#step-4-6","text":"Same as above except sudo can be dropped from all the bpfctl commands and bpfctl is now in $PATH: bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 92e3e14c-0400-4a20-be2d-f701af21873c bpfctl list UUID Type Name Location Metadata 92e3e14c-0400-4a20-be2d-f701af21873c xdp xdp image://quay.io/bpfd-bytecode/xdp_pass:latest { \"priority\": 100, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } bpfctl unload 92e3e14c-0400-4a20-be2d-f701af21873c","title":"Step 4-6"},{"location":"tutorial/#step-7-clean-up_1","text":"To unwind all the changes performed while running bpfd as a systemd service, run the following script. This command cleans up everything, including stopping the bpfd service if it is still running. sudo ./scripts/setup.sh uninstall WARNING: setup.sh uninstall cleans everything up, so /etc/bpfd/programs.d/ and /run/bpfd/bytecode/ are deleted. Save any changes or files that were created if needed.","title":"Step 7: Clean-up"},{"location":"tutorial/#bpfctl","text":"bpfctl is the command line tool for interacting with bpfd . bpfctl allows the user to load , unload and list bpf programs. Basic syntax: bpfctl --help A client for working with bpfd Usage: bpfctl <COMMAND> Commands: load unload list help Print this message or the help of the given subcommand(s) Options: -h, --help Print help information -V, --version Print version information","title":"bpfctl"},{"location":"tutorial/#bpfctl-load","text":"The bpfctl load command is used to load bpf programs. Each program type (i.e. <COMMAND> ) has it's own set of attributes specific to the program type, and those attributes MUST come after the program type is entered. There are a common set of attributes, and those MUST come before the program type is entered. bpfctl load --help Usage: bpfctl load [OPTIONS] --location <LOCATION> <COMMAND> Commands: xdp tc tracepoint help Print this message or the help of the given subcommand(s) Options: -s, --section-name <SECTION_NAME> Required if \"--from-image\" is not present: Name of the ELF section from the object file [default: ] -l, --location <LOCATION> Required: Location of Program Bytecode to load. Either Local file (file:///<path>) or bytecode image URL (image://<container image url>) -h, --help Print help Example loading from local file: bpfctl load --location file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 100 Example from image in remote repository (Note: --section-name is built into the image and is not required): bpfctl load --location image://quay.io/bpfd-bytecode/xdp_pass:latest xdp --iface vethb2795c7 --priority 100 Command specific help is also provided: bpfctl load xdp --help Usage: bpfctl load --location <LOCATION> xdp [OPTIONS] --iface <IFACE> --priority <PRIORITY> Options: -i, --iface <IFACE> Required: Interface to load program on --priority <PRIORITY> Required: Priority to run program in chain. Lower value runs first --proceed-on <PROCEED_ON>... Optional: Proceed to call other programs in chain on this exit code. Multiple values supported by repeating the parameter. Possible values: [aborted, drop, pass, tx, redirect, dispatcher_return] Default values: pass and dispatcher_return -h, --help Print help","title":"bpfctl load"},{"location":"tutorial/#bpfctl-load-examples","text":"Below are some examples of bpfctl load commands: bpfctl load --location file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o --section-name \"xdp\" xdp --iface vethb2795c7 --priority 35 bpfctl load --location file:///usr/local/src/net-ebpf-playground/.output/filter.bpf.o --section-name classifier tc --direction ingress --iface vethb2795c7 --priority 110 bpfctl load --location image://quay.io/bpfd-bytecode/tracepoint:latest tracepoint --tracepoint sched/sched_switch","title":"bpfctl load Examples"},{"location":"tutorial/#bpfctl-list","text":"The bpfctl list command lists all the loaded bpf programs: bpfctl list UUID Type Name Location Metadata c22440a7-5511-4c59-9cad-50583d0dbb3f tc-0 classifier file:///usr/local/src/net-ebpf-playground/.output/filter.bpf.o { \"priority\": 110, \"iface\": \"vethb2795c7\", \"postiion\": 0 } 6dafc471-a05c-469e-a066-0d2fbba8f19d xdp xdp file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o { \"priority\": 35, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } e46e9de9-321b-4d91-b7c5-426f4357402d tracepoint hello image://quay.io/bpfd-bytecode/tracepoint:latest { \"tracepoint\": sched/sched_switch }","title":"bpfctl list"},{"location":"tutorial/#bpfctl-unload","text":"The bpfctl unload command takes the UUID from the load or list command as a parameter, and unloads the requested bpf program: bpfctl unload c22440a7-5511-4c59-9cad-50583d0dbb3f bpfctl list UUID Type Name Location Metadata 6dafc471-a05c-469e-a066-0d2fbba8f19d xdp xdp file:///usr/local/src/xdp-tutorial/basic01-xdp-pass/xdp_pass_kern.o { \"priority\": 35, \"iface\": \"vethb2795c7\", \"position\": 0, \"proceed_on\": [\"pass\", \"dispatcher_return\"] } e46e9de9-321b-4d91-b7c5-426f4357402d tracepoint hello image://quay.io/bpfd-bytecode/tracepoint:latest { \"tracepoint\": sched/sched_switch }","title":"bpfctl unload"},{"location":"tutorial/#logging","text":"","title":"Logging"},{"location":"tutorial/#env_logger","text":"bpfd and bpfctl use the env_logger crate to log messages to the terminal. By default, only error messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. Valid values: error warn info debug trace Example: $ sudo RUST_LOG = info /usr/local/bin/bpfd [2022-08-08T20:29:31Z INFO bpfd] Log using env_logger [2022-08-08T20:29:31Z INFO bpfd::server] Loading static programs from /etc/bpfd/programs.d [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Map veth12fa8e3 to 13 [2022-08-08T20:29:31Z INFO bpfd::server] Listening on [::1]:50051 [2022-08-08T20:29:31Z INFO bpfd::server::bpf] Program added: 1 programs attached to veth12fa8e3 [2022-08-08T20:29:31Z INFO bpfd::server] Loaded static program pass with UUID d9fd88df-d039-4e64-9f63-19f3e08915ce bpfctl doesn't currently have any logs, but the infrastructure is in place if needed for future debugging.","title":"env_logger"},{"location":"tutorial/#systemd-service_1","text":"If bpfd is running as a systemd service, then bpfd will log to journald. As with env_logger, by default, only error messages are logged, but that can be overwritten by setting the RUST_LOG environment variable. bpfctl won't be run as a service, so it always uses env_logger. Example: sudo vi /usr/lib/systemd/system/bpfd.service [Unit] Description=Run bpfd as a service DefaultDependencies=no After=network.target [Service] Environment=\"RUST_LOG=Info\" <==== Set Log Level Here ExecStart=/usr/sbin/bpfd MemoryAccounting=true MemoryLow=infinity MemoryMax=infinity User=bpfd Group=bpfd AmbientCapabilities=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE CapabilityBoundingSet=CAP_BPF CAP_DAC_READ_SEARCH CAP_NET_ADMIN CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_RESOURCE Start the service: sudo systemctl start bpfd.service Check the logs: $ sudo journalctl -f -u bpfd Aug 08 16:25:04 ebpf03 systemd[1]: Started bpfd.service - Run bpfd as a service. Aug 08 16:25:04 ebpf03 bpfd[180118]: Log using journald Aug 08 16:25:04 ebpf03 bpfd[180118]: Loading static programs from /etc/bpfd/programs.d Aug 08 16:25:04 ebpf03 bpfd[180118]: Map veth12fa8e3 to 13 Aug 08 16:25:04 ebpf03 bpfd[180118]: Listening on [::1]:50051 Aug 08 16:25:04 ebpf03 bpfd[180118]: Program added: 1 programs attached to veth12fa8e3 Aug 08 16:25:04 ebpf03 bpfd[180118]: Loaded static program pass with UUID a3ffa14a-786d-48ad-b0cd-a4802f0f10b6 Stop the service: sudo systemctl stop bpfd.service","title":"Systemd Service"}]}